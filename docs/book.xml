<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="3"?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="es">
<info>
<title>El <emphasis>Wren</emphasis> libro</title>
<date>2024-03-02</date>
<copyright>
<holder>CC-BY-NC-SA 4.0</holder>
</copyright>
<author>
<personname>
<firstname>Camilo</firstname>
<othername>A.</othername>
<surname>Castro</surname>
</personname>
<email>https://github.com/clsource[@clsource]</email>
</author>
<authorinitials>CAC</authorinitials>
<cover role="front">
<mediaobject>
<imageobject>
<imagedata fileref="images/default-cover.png"/>
</imageobject>
</mediaobject>
</cover>
</info>
<colophon xml:id="_colofón">
<title>Colofón</title>
<simpara>Escrito por <link xl:href="https://ninjas.cl">Camilo Castro</link> y <link xl:href="https://github.com/ninjascl/wren-adventures/graphs/contributors">colaboradores</link>. Para <link xl:href="https://ninjas.cl">Ninjas.cl</link>.</simpara>
<simpara>Esta obra está bajo una <link xl:href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Licencia Creative Commons Atribución-No-Comercial-Compartir-Igual 4.0 Internacional</link></simpara>
<simpara><link xl:href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><inlinemediaobject>
<imageobject>
<imagedata fileref="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"/>
</imageobject>
<textobject><phrase>Licencia Creative Commons</phrase></textobject>
</inlinemediaobject></link></simpara>
<abstract>
<simpara>En este pequeño documento se detallarán lo básico del lenguaje de programación <link xl:href="http://wren.io">Wren</link>.</simpara>
</abstract>
</colophon>
<chapter xml:id="_pequeña_historia_de_wren">
<title>Pequeña Historia de <link xl:href="https://github.com/wren-lang/wren"><emphasis>Wren</link></emphasis></title>
<simpara><link xl:href="https://github.com/wren-lang/wren"><emphasis>Wren</link></emphasis> es un lenguaje de programación <link xl:href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos">orientado a objetos</link> creado por <link xl:href="http://journal.stuffwithstuff.com/">Bob Nystrom</link>, un ex desarrollador de videojuegos y creador de otros lenguajes de programación como <link xl:href="https://github.com/munificent/vigil">Vigil</link>, <link xl:href="http://finch.stuffwithstuff.com/">Finch</link> y <link xl:href="http://magpie-lang.org/">Magpie</link>. Ha escrito dos libros: <link xl:href="http://gameprogrammingpatterns.com/">Game Programming Patterns</link> y <link xl:href="http://craftinginterpreters.com/">Crafting Interpreters</link>.</simpara>
<simpara>El primer <emphasis>commit</emphasis> de <emphasis>Wren</emphasis> fue escrito el <link xl:href="https://github.com/wren-lang/wren/tree/2f6a6889f1b4a1ba86aeb169e7398704b1ee04c0">22 de Octubre del 2013</link> y su versión más reciente es la <emphasis>0.3</emphasis>. Actualmente <emphasis>Bob Nystrom</emphasis> pasó a ser colaborador y la evolución del lenguaje fue asignada a <link xl:href="https://github.com/underscorediscovery">_discovery</link> (creador del <link xl:href="https://luxeengine.com">game engine Luxe</link>).</simpara>
<simpara><emphasis>Wren</emphasis> fue creado como una alternativa a <emphasis>Lua</emphasis> y otros <link xl:href="https://en.wikipedia.org/wiki/Scripting_language">lenguajes de scripting</link> para personas que estuvieran más familiarizadas con lenguajes orientados a objetos como <emphasis>Java</emphasis>, <emphasis>C#</emphasis>, o <emphasis>C++</emphasis>. Su principal foco es la simpleza.</simpara>
<simpara>La página oficial de Wren es <link xl:href="http://wren.io">Wren.io</link>.</simpara>
<simpara>La principal característica de <emphasis>Wren</emphasis> es ser un <emphasis role="strong">lenguaje minimalista</emphasis>. Esto significa
que no todas las ideas y utilidades serán implementadas en la <emphasis>API</emphasis> oficial. Muchas
veces se tendrá la obligación de implementar funcionalidades adicionales que en otros
lenguajes están disponibles de fábrica. Normalmente la recomendación es tener
una serie de archivos con utilidades a mano y si algún día son implementadas en la <emphasis>API</emphasis>
oficial, poder reemplazarlos adecuadamente.</simpara>
<section xml:id="_qué_es_un_wren">
<title>¿Qué es un <emphasis>Wren</emphasis>?</title>
<simpara><emphasis>Wren</emphasis> es un <link xl:href="https://es.wikipedia.org/wiki/Troglodytidae">tipo de ave pequeña</link> perteneciente a la familia de los troglodítidos (que habita en cavernas o cuevas). En Chile tenemos al <link xl:href="https://www.avesdechile.cl/074.htm">Chercán o Chochin Criollo</link>.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="https://user-images.githubusercontent.com/292738/77261969-2240d580-6c71-11ea-93d0-4341e82c2f92.png"/>
</imageobject>
<textobject><phrase>Chochin Criollo - Fotografía por Juan Tassara B.</phrase></textobject>
</inlinemediaobject></simpara>
<literallayout class="monospaced">Fotografía por Juan Tassara B en https://www.avesdechile.cl.</literallayout>
<simpara>Esta familia de aves se caracteriza por sus canciones elaboradas y complejas. Es uno de los más queridos compositores de las aves. Sus canciones tienen una rica variedad de cromatura musical.</simpara>
<simpara>También son aves muy hogareñas que prefieren quedarse en un mismo territorio a emigrar. Cuando vuelan sorprenden con la gran altura que pueden alcanzar y su rapidez. ¡Nunca sabes en que dirección van a salir!.</simpara>
<simpara>En las tradiciones celtas, el <emphasis>Wren</emphasis> es un símbolo de vivacidad y actividad.</simpara>
</section>
<section xml:id="_por_qué_aprender_wren">
<title>¿Por qué aprender <emphasis>Wren</emphasis>?</title>
<simpara>Existen algunos lenguajes interpretados usados para ser incrustados dentro de aplicaciones. <link xl:href="https://www.lua.org/"><emphasis>Lua</emphasis></link> es uno de los más populares. Actualmente también son populares <link xl:href="https://developer.mozilla.org/en-US/docs/Web/JavaScript"><emphasis>JavaScript</emphasis></link> o <link xl:href="https://www.python.org/"><emphasis>Python</emphasis></link>.</simpara>
<simpara><emphasis>Lua</emphasis> es genial, simple y rápido. Pero muchas veces su naturaleza es un poco incómoda para personas más acostumbaradas a lenguajes como <link xl:href="https://isocpp.org/"><emphasis>C++</emphasis></link> o <link xl:href="https://openjdk.java.net/"><emphasis>Java</emphasis></link>. La sintaxis es diferente y la semántica del modelo de objetos es algo inusual.</simpara>
<simpara><emphasis>Wren</emphasis> es una alternativa a <emphasis>Lua</emphasis> pensada para personas mas familiarizadas con lenguajes orientados a objetos.</simpara>
<simpara>Acá podemos comparar la implementación de una clase llamada <emphasis>Cuenta</emphasis> entre
<emphasis>Lua</emphasis> y <emphasis>Wren</emphasis>.</simpara>
<formalpara>
<title>Lua</title>
<para>
<programlisting language="lua" linenumbering="numbered">-- cuenta.lua

Cuenta = {}
Cuenta.__index = Cuenta

function Cuenta.crear(balance)
  local cuenta = {}             -- nuevo objeto
  setmetatable(cuenta,Cuenta)   -- hacer el objeto cuenta tenga las propiedades de Cuenta
  cuenta.balance = balance      -- inicializar el objeto
  return cuenta
end

function Cuenta:retirar(monto)
  self.balance = self.balance - monto
end

-- crear y usar una Cuenta
cuenta = Cuenta.crear(1000)
cuenta:retirar(100)</programlisting>
</para>
</formalpara>
<formalpara>
<title>Wren</title>
<para>
<programlisting language="js" linenumbering="numbered">// cuenta.wren

class Cuenta {
  construct crear(balance) { _balance = balance }
  retirar(monto) { _balance = _balance - monto }
}

// crear y usar una Cuenta
var cuenta = Cuenta.crear(1000)
cuenta.retirar(100)</programlisting>
</para>
</formalpara>
<simpara>Los lenguajes orientados a objetos y clases tradicionalmente tienen una reputación
de ser complejos. Esto es principalmente por que los lenguajes que implementan este paradigma
son complejos: <emphasis>C++</emphasis>, <emphasis>Java</emphasis>, <link xl:href="https://docs.microsoft.com/en-us/dotnet/csharp/"><emphasis>C#</emphasis></link>, <link xl:href="https://www.ruby-lang.org/en/"><emphasis>Ruby</emphasis></link> y <emphasis>Python</emphasis>.</simpara>
<simpara>Uno de los objetivos de <emphasis>Wren</emphasis> es demostrar que son dichos lenguajes los complejos, no la orientación a objetos y clases en sí. <link xl:href="https://es.wikipedia.org/wiki/Smalltalk"><emphasis>Smalltalk</emphasis></link> fue uno de los precursores y la inspiración para muchos de aquellos lenguajes. Es tan simple que toda su sintaxis puede ser escrita en una <emphasis>tarjeta kardex</emphasis>. <emphasis>Wren</emphasis> desea ser igual de minimalista, pero al mismo contar con el poder expresivo de las clases y orientación a objetos.</simpara>
<simpara>Finalmente para responder la pregunta de <emphasis>"¿Por qué aprender Wren?"</emphasis>. Principalmente por que aprender un nuevo lenguaje de programación siempre entregará experiencia que puede ser extrapolada a otros ámbitos y contextos. Tal vez sea más simple de aprender un concepto en <emphasis>Wren</emphasis> que en <emphasis>Python</emphasis> o <emphasis>Lua</emphasis>. Quizás un lenguaje de nicho como <emphasis>Wren</emphasis> no tenga muchas ofertas laborales que lo soliciten, pero todo lo aprendido siempre será nutritivo para el desarrollo profesional.</simpara>
</section>
<section xml:id="_cómo_usar_wren">
<title>¿Cómo usar <emphasis>Wren</emphasis>?</title>
<simpara><emphasis>Wren</emphasis> es un lenguaje interpretado, lo que significa que no requiere de compilación. Basta simplemente tener un intérprete para ejecutar los algoritmos. Hay varias alternativas.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link xl:href="https://github.com/wren-lang/wren">Compilar tu propio intérprete de <emphasis>Wren</emphasis></link>. Esta es la opción para valientes.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/wren-lang/wren-cli/releases">Utiliza <emphasis>Wren CLI</emphasis></link> para ejecutar archivos <emphasis>*.wren</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Utiliza un engine de juegos como <link xl:href="https://domeengine.com/"><emphasis>Dome</emphasis></link>, <link xl:href="https://tic.computer"><emphasis>TIC 80</emphasis></link> o <link xl:href="https://luxeengine.com/alpha/"><emphasis>Luxe</emphasis></link> que traen <emphasis>Wren</emphasis> listo para llegar y utilizar.</simpara>
</listitem>
<listitem>
<simpara>Utiliza <link xl:href="https://wren.io/try/"><emphasis>Wren Try</emphasis></link> para probar el lenguaje en tu navegador.</simpara>
</listitem>
</orderedlist>
<simpara>Una vez que tengas tu intérprete instalado puedes ejecutar por ejemplo`./wren main.wren` para ver el resultado de tu script.</simpara>
</section>
<section xml:id="_wren_cli">
<title><link xl:href="https://github.com/wren-lang/wren-cli">Wren CLI</link></title>
<simpara>La terminal de <emphasis>Wren</emphasis> llamada <emphasis>Wren CLI</emphasis> (<link xl:href="https://es.wikipedia.org/wiki/Interfaz_de_l%C3%ADnea_de_comandos">Interfaz de línea de comandos</link>) permite dos modos de operación. El primero es el modo <link xl:href="https://es.wikipedia.org/wiki/REPL"><emphasis>REPL</emphasis></link> (Bucle Lectura-Evaluación-Impresión) el cual nos permite evaluar las instrucciones una a una. El segundo modo es el intérprete que permite ejecutar scripts <emphasis>Wren</emphasis>.</simpara>
<simpara>Si ejecutamos simplemente el comando <literal>./wren</literal> entraremos al modo <emphasis>REPL</emphasis>. Donde se nos mostrará un simpático pajarito y la versión de <emphasis>Wren</emphasis> instalada.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="https://user-images.githubusercontent.com/292738/77837383-22444800-713f-11ea-8db4-3f404faabc10.png"/>
</imageobject>
<textobject><phrase>Wren CLI</phrase></textobject>
</inlinemediaobject></simpara>
<section xml:id="_operaciones_matemáticas">
<title>Operaciones Matemáticas</title>
<simpara>Podremos ejecutar operaciones matemáticas como <literal>5 * 5</literal>.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="https://user-images.githubusercontent.com/292738/77837948-7ce0a280-7145-11ea-8b43-3f91f7491b35.png"/>
</imageobject>
<textobject><phrase>5 * 5</phrase></textobject>
</inlinemediaobject></simpara>
</section>
<section xml:id="_system_print">
<title>System.print()</title>
<simpara>O También mostrar un mensaje utilizando <literal>System.print()</literal>.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="https://user-images.githubusercontent.com/292738/77837982-d517a480-7145-11ea-86f4-7a24e5ecc628.png"/>
</imageobject>
<textobject><phrase>System.print()</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>¿Por qué aparece la palabra <literal>Plop!</literal> dos veces?. Simplemente por que la primera vez es el resultado de la operación <literal>System.print()</literal> (mostrar un valor), mientras que la segunda vez está mostrando el valor retornado por <literal>System.print()</literal>, el cual es el mismo texto.</simpara>
</section>
<section xml:id="_errores">
<title>Errores</title>
<simpara>Si cometemos algún error <emphasis>Wren CLI</emphasis> nos avisará con un bonito mensaje.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="https://user-images.githubusercontent.com/292738/77838174-c4682e00-7147-11ea-9e82-ffd2dc4dd1f9.png"/>
</imageobject>
<textobject><phrase>Error</phrase></textobject>
</inlinemediaobject></simpara>
</section>
<section xml:id="_ejecución_de_archivos">
<title>Ejecución de archivos</title>
<simpara>Cuando necesitamos algo mucho más avanzado podemos utilizar archivos que finalicen con la extensión <emphasis>*.wren</emphasis>. El nombre más común es <emphasis>main.wren</emphasis>, aunque puedes llamarlo con cualquier nombre. Para ejecutar un archivo específico simplemente se debe utilizar <literal>./wren &lt;archivo.wren&gt;</literal>.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Creamos un nuevo archivo llamado <literal>main.wren</literal>.</simpara>
</listitem>
<listitem>
<simpara>Escribimos nuestro código (En este caso <literal>System.print("Plop!")</literal>) y guardamos.</simpara>
</listitem>
<listitem>
<simpara>Finalmente Ejecutamos <literal>./wren main.wren</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>Deberíamos ver un resultado similar a este:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="https://user-images.githubusercontent.com/292738/77839010-7c4d0980-714f-11ea-90df-4330a821d207.png"/>
</imageobject>
<textobject><phrase>Plop!</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>Notar como solamente aparece una vez "Plop!", ya que no estamos en modalidad <emphasis>REPL</emphasis>.</simpara>
</section>
<section xml:id="_códigos_de_salida_exit_code">
<title>Códigos de salida (Exit code)</title>
<simpara>Cada vez que un programa termina su ejecución devuelve un código numérico para indicar si terminó exitosamente o tuvo un algún tipo de error mientras se ejecutaba.</simpara>
<simpara>La convención tradicional es considerar el código cero (0) como éxito y cualquier otro número como error. No hay un estándar definido para la asignación de números de error. <emphasis>Wren</emphasis> se basa levemente en los códigos utilizados por el sistema operativo <link xl:href="https://github.com/openbsd/src/blob/master/include/sysexits.h"><emphasis>BSD</emphasis></link>.</simpara>
<simpara>Actualmente no puedes elegir el código de error. <emphasis>Wren</emphasis> automáticamente asignará el código que mejor se ajuste a la situación. Por ejemplo si utilizar la instrucción para terminar la ejecución del programa <literal>Fiber.abort("Mensaje de Error")</literal> el código asignado sera de 70 (error interno del software).</simpara>
<simpara>La siguiente es una tabla con los códigos de BSD más algunos otros adicionales.</simpara>
<screen linenumbering="numbered">0 - Fin del programa exitoso
1 - Error desconocido
2 - (grep) Uso incorrecto del comando | (bash) Error de entrada/salida
64 - Uso incorrecto del comando
65 - Error de formato de datos
66 - Sin acceso a la entrada
67 - Dirección desconocida
68 - Nombre de dominio (host name) desconocido
69 - Servicio no disponible
70 - Error interno del software
71 - Error de sistema
72 - Archivo crítico del sistema no encontrado
73 - Imposible de crear archivo de salida
74 - Error de entrada/salida
75 - Falla temporal
76 - Error remoto en protocolo
77 - Permiso denegado
78 - Error de configuración
126 - Comando encontrado, pero no es ejecutable
127 - Comando no encontrado
128 - Código de salida no válido
128   Error fatal terminado por kill -9
140 - Comando terminado por Ctrl-C
141 - Comando terminado por Ctrl-D
255 - Código de salida fuera de rango</screen>
<simpara>Esta es la lista de los errores <link xl:href="https://raw.githubusercontent.com/wren-lang/wren/58611240e75522df1a17ba29d8fd2109b4d2f657/test/test.h">usados en <emphasis>Wren</emphasis></link>:</simpara>
<programlisting language="c" linenumbering="numbered">// Exit codes used by the wren binaries, following the BSD standard
//
// The interpreter was used with an incorrect number of arguments
#define WREN_EX_USAGE 64

// Compilation error
#define WREN_EX_DATAERR 65

// Runtime error
#define WREN_EX_SOFTWARE 70

// Cannot open input file
#define WREN_EX_NOINPUT 66

// I/O Error
#define WREN_EX_IOERR 74</programlisting>
<simpara>Puedes verificar el código numérico de salida utilizando el siguiente comando (bash)</simpara>
<simpara><literal>./wren main.wren | echo "Exit code ${PIPESTATUS[0]}"</literal></simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="https://user-images.githubusercontent.com/292738/77839414-d9968a00-7152-11ea-9bd3-b42ff06a4d1a.png"/>
</imageobject>
<textobject><phrase>Exit Code 0</phrase></textobject>
</inlinemediaobject></simpara>
</section>
</section>
<section xml:id="_ejercicios">
<title>Ejercicios</title>
<section xml:id="chap1-ex1">
<title>¡Hola Wren!</title>
<simpara>Es una <link xl:href="https://es.wikipedia.org/wiki/Hola_mundo">tradición</link> que cuando se esté aprendiendo
un lenguaje de programación se escriba una variante
del mensaje "!Hola mundo¡". Este es un programa
muy simple que permite verificar que tu computadora
esta correctamente configurada para correr programas
en <emphasis>Wren</emphasis>.</simpara>
<simpara>Para este ejercicio simplemente se debe crear un nuevo
archivo llamado <literal>hola.wren</literal> con una única instrucción
que muestre el mensaje "¡Hola Wren!".</simpara>
<simpara>Luego ejecutar el programa utilizando el intérprete de <emphasis>Wren</emphasis>.</simpara>
<formalpara>
<title>Ejecución</title>
<para><literal>$ ./wren hola.wren</literal></para>
</formalpara>
<formalpara>
<title>Salida</title>
<para>
<screen linenumbering="numbered">¡Hola Wren!</screen>
</para>
</formalpara>
<formalpara>
<title>Código</title>
<para>
<programlisting language="js" linenumbering="numbered">// muestra: ¡Hola Wren!</programlisting>
</para>
</formalpara>
<formalpara>
<title>Solución</title>
<para><xref linkend="chap1-ex1-sol"/></para>
</formalpara>
</section>
</section>
</chapter>
<chapter xml:id="_nociones_básicas">
<title>Nociones Básicas</title>
<simpara>Todo lenguaje de programación define estructuras base que
determinan la forma de escribir el lenguaje. El siguiente
capítulo detalla las normas básicas con las que funciona
<emphasis>Wren</emphasis>.</simpara>
<section xml:id="_tipos_de_datos">
<title>Tipos de datos</title>
<simpara>Todos los tipos de datos en <emphasis>Wren</emphasis> son objetos, instancias de una clase específica. Las operaciones son métodos disponibles en dichas clases.</simpara>
<formalpara>
<title>Wren</title>
<para>Estas son las clases disponibles dentro del lenguaje <emphasis>Wren</emphasis> "vainilla".</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>Bool</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Class</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Fiber</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Fn</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>List</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Map</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Null</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Num</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Object</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Range</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Sequence</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>String</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>System</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Meta</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Random</emphasis></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Importante</title>
<para>No se puede heredar desde estas clases debido al problema de <link xl:href="https://es.wikipedia.org/wiki/Reentrancia_(inform%C3%A1tica)"><emphasis>Reentrancia</emphasis></link> (<emphasis>Wren</emphasis> no tiene esta capacidad). Para extender solo es posible usando la composición (Crear una nueva clase). Esto significa que al llamar a un método de una clase que herede de un tipo base, la máquina virtual no podrá diferenciar los métodos (Ya que son clases creadas con código de bajo nivel), lo que puede causar errores, por esta razón no está permitido heredar de las clases primitivas.</para>
</formalpara>
<formalpara>
<title>Wren CLI</title>
<para>Estas clases son exclusivas de la <emphasis>Wren CLI</emphasis>. No estarán disponibles fuera del entorno de ejecución de este intérprete de <emphasis>Wren</emphasis>.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>Directory</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>File</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Stat</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Stdin</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Stdout</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Platform</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Process</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Scheduler</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Timer</emphasis></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_variables">
<title>Variables</title>
<simpara>Una variable es un contenedor de un valor específico.
Este valor puede ser una cadena de caracteres, númerico, booleano u otro tipo de objeto.</simpara>
<programlisting language="js" linenumbering="numbered">var mensaje = "Hola mundo Wren"
System.print(mensaje)</programlisting>
<simpara>Se puede modificar el valor posteriormente</simpara>
<programlisting language="js" linenumbering="numbered">var mensaje = "Hola mundo Wren"
System.print(mensaje)

mensaje = "El chercán es una bonita ave"
System.print(mensaje)</programlisting>
<simpara>Si usamos una variable sin haberla declarado antes
recibiremos un error similar a lo siguiente:</simpara>
<programlisting language="js" linenumbering="numbered">var mensaje = "Hola"
System.print(mensaj)
[repl line 1] Error at 'mensaj': Variable is used but not defined.</programlisting>
<simpara>Debemos siempre procurar que todas nuestras variables estén declaradas
dentro del contexto y que no existan errores de escritura en sus nombres.</simpara>
</section>
<section xml:id="_identificadores">
<title>Identificadores</title>
<simpara>Similar al <emphasis>Lenguaje C</emphasis>, para los indentificadores (nombres de variables, clases, metodos, funciones) se pueden utilizar los caracteres de la <link xl:href="http://www.asciitable.com/">lista <literal>ascii</literal></link> y comenzar con un caracter alfabético o guión bajo. Los identificadores en <emphasis>Wren</emphasis> diferencian entre mayúsculas y minúsculas. Solo se permiten letras (<literal>A - Z</literal>, <literal>a - z</literal>), números (<literal>0 - 9</literal>) y guión bajo (<literal>_</literal>). No se permiten espacios o comenzar con un número o guión alto (<literal>-</literal>).</simpara>
<section xml:id="_ejemplo_de_identificadores_válidos">
<title>Ejemplo de Identificadores válidos</title>
<programlisting language="js" linenumbering="numbered">hola
camelCase
PascalCase
_under_score
abc123
TODAS_MAYUSCULAS</programlisting>
</section>
<section xml:id="_ejemplo_de_identificadores_no_válidos">
<title>Ejemplo de Identificadores no válidos</title>
<screen linenumbering="numbered">13hola
mi-variable
$miVariable
mi variable
ñandú
👨miMetodo
Mi👩clase</screen>
</section>
<section xml:id="_unicode">
<title>Unicode</title>
<simpara>No están permitidos caracteres <link xl:href="https://es.wikipedia.org/wiki/UTF-8">UTF-8</link> como la <literal>Ñ</literal> o los emojis en los identificadores. Sin embargo las <literal>Strings</literal> las soportan en su contenido sin problemas. Hay lenguajes como <link xl:href="https://swift.org/"><emphasis>Swift</emphasis></link> o <link xl:href="https://www.emojicode.org/">Emoji Code</link> que si soportan identificadores con emojis, aunque la utilidad de esta práctica es debatible.</simpara>
<formalpara>
<title>EmojiCode</title>
<para>
<screen linenumbering="numbered">🏁 🍇
  😀 🔤Hello World!🔤❗️
🍉</screen>
</para>
</formalpara>
</section>
<section xml:id="_identificadores_que_inician_con_guión_bajo">
<title>Identificadores que inician con guión bajo</title>
<simpara>Un caso especial es para los identificadores con guión bajo como <literal>_color</literal> (un guión bajo al principio) y <literal>__sabor</literal> (dos guiones bajos al principio). Con un guión bajo indica que es una propiedad de instancia, mientras que con dos guiones bajos indican que es una propiedad de clase. Más detalles en la sección de Clases.</simpara>
</section>
<section xml:id="_identificadores_de_clase">
<title>Identificadores de clase</title>
<simpara>Para <emphasis>Wren</emphasis> es importante que las clases comiencen
su nombre con mayúsculas. Si bien es posible definir clases con letras minúsculas no es recomendable hacerlo debido a que pueden colisionar con variables dentro del contexto de clase o método.</simpara>
<simpara>Ejemplos</simpara>
<programlisting language="js" linenumbering="numbered">// Asociamos la clase `Numero` como un substituto para llamar a la clase `Num`
var Numero = Num</programlisting>
<programlisting language="js" linenumbering="numbered">// Dará error. No se puede heredar de las clases primitivas.
class Numero is Num {}</programlisting>
<programlisting language="js" linenumbering="numbered">// Es posible nombrar con minúsculas, pero puede dar
// conflictos de contexto al momento de usarlo dentro
// de una clase. (Puede hacer colisión con nombres de variable)
class numero {}</programlisting>
</section>
<section xml:id="_recomendaciones">
<title>Recomendaciones</title>
<itemizedlist>
<listitem>
<simpara>Los nombres de los identificadores deben ser descriptivos, sin ser muy largos. Ejemplo <emphasis>"ruedasMotocicleta"</emphasis> es mejor que solo "ruedas" y "numero_de_ruedas_en_una_moto".</simpara>
</listitem>
<listitem>
<simpara>La letra <emphasis>"l"</emphasis> mínuscula y la letra <emphasis>"O"</emphasis> mayúscula puede ser confundida con el número <emphasis>"1"</emphasis> y "0" respectivamente.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_saltos_de_línea">
<title>Saltos de línea</title>
<simpara><emphasis>Wren</emphasis> utiliza los saltos de línea (<literal>\n</literal>), por lo que no es necesario utilizar el punto y coma (<literal>;</literal>) para separar instrucciones. Sin embargo omite los saltos de línea si la instrucción espera más información para ser válida.</simpara>
<section xml:id="_ejemplo_lista_de_elementos">
<title>Ejemplo: Lista de elementos</title>
<programlisting language="js" linenumbering="numbered">var animales = [
  "perro",
  "gato",
  "condor",
  "huemul"
]</programlisting>
</section>
<section xml:id="_ejemplo_parámetros_de_un_método">
<title>Ejemplo: Parámetros de un método</title>
<programlisting language="js" linenumbering="numbered">MiClase.metodo(
  parametro1,
  parametro2,
  parametro3
)</programlisting>
</section>
<section xml:id="_ejemplo_condicionales">
<title>Ejemplo: Condicionales</title>
<simpara>Los saltos de línea son considerados en la declaración de bloques de código.
Por lo tanto es importante la posición de las llaves (<emphasis>"{}"</emphasis>) dentro de una instrucción.</simpara>
<programlisting language="js" linenumbering="numbered">// Correcto
if (condiccion == true) { x = 0 }</programlisting>
<programlisting language="js" linenumbering="numbered">// Correcto
if (condiccion == true)   {
  x = 0
}</programlisting>
<programlisting language="js" linenumbering="numbered">// Correcto
if (condicion == true) x = 0</programlisting>
<simpara>Condicionales de una sola línea. Tienen el formato de
<literal>condición</literal> <literal>?</literal> <literal>retorno si es verdadero</literal> <literal>:</literal> <literal>retorno si es falso</literal>.</simpara>
<programlisting language="js" linenumbering="numbered">  // Si la condición es verdadera, x será 0. Si es falsa, x será 1
  var x = condicion ? 0 : 1</programlisting>
<simpara>Utilizando el operador <literal>OR (||)</literal>. Se puede asignar un valor predeterminado a una variable.</simpara>
<programlisting language="js" linenumbering="numbered">  // Si x es nulo se asignará 0. Caso contrario mantiene su valor anterior.
  x = x || 0</programlisting>
<simpara>Si la llave no está presente en la misma línea, gatillará un error.</simpara>
<programlisting language="js" linenumbering="numbered">// Error
if (condiction == true)
{
  x = 0
}</programlisting>
</section>
<section xml:id="_ejemplo_generar_un_número_al_azar_del_0_al_9">
<title>Ejemplo: Generar un número al azar del 0 al 9</title>
<simpara>Al considerar los saltos de línea significativos,
provoca un comportamiento inusual al momento de llamar métodos.</simpara>
<literallayout class="monospaced">Los números pseudo aleatorios son generados utilizando la clase `Random`. Para generar un número del 0 al 9 se necesita utilizar 10, ya que el número máximo utilizado no está incluido dentro de la secuencia. Es decir se incluye 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 (total 10 números) dentro de los posibles resultados.</literallayout>
<simpara>Instrucción en una sola línea.</simpara>
<programlisting language="js" linenumbering="numbered">Random.new().int(10)</programlisting>
<simpara>Esto no es válido en <emphasis>Wren</emphasis> (Pero si es válido en la mayoría de los lenguajes de programación).</simpara>
<programlisting language="js" linenumbering="numbered">Random
.new()
.int(10)</programlisting>
<simpara>Para ser válido necesitamos poner un punto al final de la línea.</simpara>
<programlisting language="js" linenumbering="numbered">Random.
new().
int(10)</programlisting>
<simpara>Este comportamiento inusual espera ser reparado en la versión <literal>0.4</literal>.</simpara>
</section>
<section xml:id="_ejemplo_error">
<title>Ejemplo: <emphasis role="strong">Error</emphasis></title>
<simpara>La siguiente línea arroja error debido a que no tiene un salto de línea o una operación.</simpara>
<programlisting language="js" linenumbering="numbered">Random.new().int(10) Random.new().int(10)</programlisting>
</section>
</section>
<section xml:id="_retorno_implícito">
<title>Retorno implícito</title>
<simpara>Al tener instrucciones de una sola línea, <emphasis>Wren</emphasis> asume
la existencia de una instrucción de retorno (<emphasis>"return"</emphasis>).
Si no hay un valor, se asume que el valor de retorno
es <emphasis>null</emphasis>.</simpara>
<programlisting language="js" linenumbering="numbered">class Auto {
  // ruedas retornará siempre el valor "4"
  ruedas {4}

  // similar a ruedas, pero usando una instrucción "return" explícita
  puertas {
    return 2
  }
}</programlisting>
</section>
<section xml:id="_palabras_reservadas">
<title>Palabras Reservadas</title>
<simpara><emphasis>Wren</emphasis> es un lenguaje simple y pequeño. Sus palabras reservadas son las siguientes:</simpara>
<programlisting language="js" linenumbering="numbered">break class construct else false for foreign if import
in is null return static super this true var while</programlisting>
<simpara>Una palabra reservada tiene un significado especial para <emphasis>Wren</emphasis>, por lo que no se recomienda usarlas para llamar a variables o clases. De esta forma se evita conflictos y confusiones.</simpara>
<section xml:id="_caracteres_significativos">
<title>Caracteres significativos</title>
<itemizedlist>
<listitem>
<simpara>Caracteres comunes (<literal>+ - * / % &lt; &gt; = ! ( ) [ ] | . " { } , &amp; ^ ? : ~ _</literal>)</simpara>
</listitem>
<listitem>
<simpara>Retorno de carro (<literal>\n</literal>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_funciones_fn">
<title>Funciones (<emphasis>Fn</emphasis>)</title>
<simpara>Las funciones en <emphasis>Wren</emphasis> son instancias de la clase <emphasis>Fn</emphasis> y deben ser llamadas utilizando su método <emphasis>call()</emphasis>. Al ser un objeto más, pueden ser pasadas como parámetros a métodos u otras funciones.</simpara>
<programlisting language="js" linenumbering="numbered">var mostrar = Fn.new {|parametro|
  System.print(parametro)
}

// muestra: hola
mostrar.call("hola")</programlisting>
</section>
<section xml:id="_fibras_fiber">
<title>Fibras (<emphasis>Fiber</emphasis>)</title>
<simpara>Son similares a las funciones, con la diferencia en que se ejecutarán en un hilo (<emphasis>thread</emphasis>) distinto. Además del método <emphasis>call()</emphasis> tienen un método <emphasis>try()</emphasis> usado normalmente para "atajar" errores.</simpara>
<programlisting language="js" linenumbering="numbered">var mostrar = Fn.new {|parametro|
  System.print(parametro)
}

// Si existe un error se almacenará en la variable error
var error = Fiber.new { mostrar.call("hola") }.try()</programlisting>
</section>
<section xml:id="_clases_class">
<title>Clases (<emphasis>class</emphasis>)</title>
<simpara>Las clases se declaran utilizando la palabra clave <emphasis>class</emphasis> antes del nombre.</simpara>
<programlisting language="js" linenumbering="numbered">class MiClase {}</programlisting>
<simpara>La herencia se define utilizando la palabra clave <emphasis>is</emphasis>.
Solo se heredan los métodos de instancia.
Propiedades de clase (<emphasis>_var) y de instancia (_var),
constructores y métodos de clase (_static</emphasis>) no son heredados (todos son privados).</simpara>
<programlisting language="js" linenumbering="numbered">class Animal {
  // la propiedad _nombre solo puede ser accesible
  // a clases hijos si se definen como métodos accesadores
  nombre {_nombre}

  // creamos un mutador de la clase
  nombre = (value) {
    _nombre = value
  }

  imprimir() {
    System.print(nombre)
  }
}

class Perro is Animal {

  imprimir() {
    System.print("imprimir en hijo")
  }

  // constructores no son heredables
  construct nuevo(nom) {
    // llamamos al método mutador de la clase padre
    this.nombre = nom

    // Usamos `super` para llamar a un método de la clase padre
    // Muestra "Joe" usando el método accesador del padre
    super.imprimir()

    // Muestra null
    System.print(_nombre)
  }
}

var perrito = Perro.nuevo("Joe")</programlisting>
<simpara>Para definir un constructor se utiliza la palabra clave <literal>construct</literal>.
Para llamar a la instancia se usa <literal>this</literal> (opcional).</simpara>
<programlisting language="js" linenumbering="numbered">class Auto {
  construct nuevo() {
    System.print(this)
  }
}</programlisting>
<simpara>Para definir un método o propiedad de clase se utiliza la palabra clave <emphasis>static</emphasis>.</simpara>
<programlisting language="js" linenumbering="numbered">class Fruta {
  // accesador (getter)
  static cantidad {__cantidad}

  // mutador (setter)
  static cantidad = (value) {
    // doble guión bajo indica propiedad de clase
    __cantidad = value
  }

  // método de clase
  static comer() {
    cantidad = cantidad - 1
  }
}</programlisting>
<simpara>Para saber el padre de la clase se utiliza la propiedad <literal>supertype</literal>.
Esta propiedad debe ser llamada recursivamente para obtener el árbol de herencia.</simpara>
<itemizedlist>
<listitem>
<simpara>La clase primitiva base de todas es <literal>Object</literal>.</simpara>
</listitem>
<listitem>
<simpara>No se puede heredar de los primitivos como <literal>String</literal>, <literal>Num</literal>, <literal>Map</literal>, entre otros.</simpara>
</listitem>
</itemizedlist>
<programlisting language="js" linenumbering="numbered">class Animal {}

class Perro is Animal {}

System.print(Perro.supertype) // Animal

if (Perro.supertype == Animal) {
  // Perro es animal
}</programlisting>
<simpara>Si queremos saber el tipo de una <emphasis>instancia</emphasis> se puede usar <literal>is</literal>.</simpara>
<programlisting language="js" linenumbering="numbered">var perrito = Perro.new()
if (perrito is Perro) {
  // perrito es Perro
}

if (Perro is Animal) {
  // Falso, ya que son clases distintas
}</programlisting>
<itemizedlist>
<listitem>
<simpara>Las propiedades <literal>type</literal>, <literal>supertype</literal> y <literal>name</literal> vienen dentro de cada clase.</simpara>
</listitem>
<listitem>
<simpara><literal>Object</literal> es la única clase que no tiene <literal>supertype</literal>.</simpara>
</listitem>
</itemizedlist>
<programlisting language="js" linenumbering="numbered">class Animal {}

class Perro is Animal {}

System.print(Perro.name)
System.print(Perro.type)

System.print(Perro.supertype.name)
System.print(Perro.supertype.type)
System.print(Perro.supertype.supertype)

System.print(Object.supertype)</programlisting>
</section>
<section xml:id="_control_de_flujo">
<title>Control de Flujo</title>
<simpara>Existen las estructuras de control de flujo tradicionales: <emphasis>if</emphasis>, <emphasis>for</emphasis>, <emphasis>while</emphasis> y <emphasis>break</emphasis>.</simpara>
<programlisting language="js" linenumbering="numbered">if (condicion) {
  // codigo
}</programlisting>
<programlisting language="js" linenumbering="numbered">while (condicion) {
  // codigo
}</programlisting>
<programlisting language="js" linenumbering="numbered">for (elemento in secuencia) {
  // codigo
  break
}</programlisting>
</section>
<section xml:id="_importar">
<title>Importar</title>
<simpara>Para separar el código en diversos archivos esta la instrucción <literal>import</literal>.
El leer los archivos e importar su contenido dependerá del intérprete.</simpara>
<simpara>La instrucción <literal>import</literal> va de la mano con la palabra <literal>for</literal>.</simpara>
<programlisting language="js" linenumbering="numbered">// El módulo se llama "random" e importamos la clase "Random" que está dentro de este módulo
import "random" for Random</programlisting>
</section>
<section xml:id="_object">
<title><link xl:href="https://wren.io/modules/core/object.html">Object</link></title>
<simpara>Es la clase padre de todas las demás clases en <emphasis>Wren</emphasis>.</simpara>
<simpara>Algunos métodos destacables:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>toString</literal>: Convierte el objeto a un <emphasis>String</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><literal>type</literal>: Retorna la clase a la cual el pertenece el objeto.</simpara>
</listitem>
</itemizedlist>
<programlisting language="js" linenumbering="numbered">// Convertimos los datos a un String serializable
3.toString
["1",2,"tres", true].toString

// similar a "1" == "2", pero sin posibilidad de sobre escribir el operador
Object.same("1", "2")

// verificamos que la instancia pertenezca a la clase
if ("1" is String) {
  System.print("hola")
}</programlisting>
</section>
<section xml:id="_comentarios">
<title>Comentarios</title>
<simpara>Cuando se comienza a escribir código más elaborado, existe mayor necesidad de pensar
como codificar las soluciones a los problemas. Una vez que se soluciona el problema,
se dedicará una gran cantidad de tiempo en revisar y perfeccionar el algoritmo.</simpara>
<simpara>Los comentarios te permiten escribir en lenguaje humano como Inglés o Español, dentro
de los programas.</simpara>
<simpara>Los comentarios en <emphasis>Wren</emphasis> utilizan la misma sintaxis que el <link xl:href="https://es.wikipedia.org/wiki/C_(lenguaje_de_programaci%C3%B3n)"><literal>Lenguaje de Programación C</literal></link>.</simpara>
<simpara>Los símbolos son los siguientes: <literal>/* */</literal> (multi línea) y <literal>//</literal> (línea única).</simpara>
<programlisting language="js" linenumbering="numbered">// Comentario de una sola línea

/*
Este comentario
tiene múltiples
líneas
*/</programlisting>
<simpara>Se pueden anidar los comentarios. útil para comentar código que ya tenga comentarios.</simpara>
<programlisting language="js" linenumbering="numbered">/*
Este comentario
tiene múltiples
líneas.
  /* También puedes incluir comentarios,
  dentro de comentarios multi línea.
  */
*/</programlisting>
<section xml:id="_tip_comentarios_tijera">
<title>Tip: Comentarios Tijera</title>
<simpara>Puedes combinar los comentarios de una sola línea con los de múltiples líneas para
comentar/descomentar rápidamente secciones de código. Se llaman comentarios tijera
por que pueden "cortar" un código para no ser ejecutado.</simpara>
<programlisting language="js" linenumbering="numbered">// /*
  codigo()
// */</programlisting>
<simpara>Al eliminar el comentario de la primera línea, el código será comentado. De esta forma rápidamente
puedes activar o desactivar secciones de código.</simpara>
<programlisting language="js" linenumbering="numbered">/*
  codigo()
// */</programlisting>
<simpara>Puede aún ser más simplificado de esta forma</simpara>
<programlisting language="js" linenumbering="numbered">//*
  codigo()
// */</programlisting>
<simpara>Si se elimina el primer <literal>/</literal> el código será comentado. Por lo que se ahorra un par de movimientos al realizar el comentario.</simpara>
<programlisting language="js" linenumbering="numbered">/*
  codigo()
// */</programlisting>
</section>
<section xml:id="_tip_comentarios_de_parámetros">
<title>Tip: Comentarios de parámetros</title>
<simpara>En <emphasis>Wren</emphasis> no es posible llamar a los parámetros por su nombre. Por lo que si utilizas una función
con algunos parámetros, puede ser útil comentarlos.</simpara>
<programlisting language="js" linenumbering="numbered">circulo(/* x */ 10, /* y */ 20, /* radio */ 10)</programlisting>
<simpara>O mejor aún utilizar variables con nombres significativos</simpara>
<programlisting language="js" linenumbering="numbered">var x = 10
var y = 20
var radio = 10
circulo(x, y, radio)</programlisting>
</section>
<section xml:id="_cómo_es_un_buen_comentario">
<title>¿Cómo es un buen comentario?</title>
<itemizedlist>
<listitem>
<simpara>Es completo, corto y directo. La mayoría de los comentarios deberían ser escritos en párrafos.</simpara>
</listitem>
<listitem>
<simpara>Explica tu forma de pensar, para que cuando regreses a leer el código en el futuro puedas comprender cómo se ha resuelto el problema.</simpara>
</listitem>
<listitem>
<simpara>También explica pensando en otros, para que otras personas puedan trabajar en tu código y entender cómo lo haz estructurado.</simpara>
</listitem>
<listitem>
<simpara>Explica una sección difícil con mayor detalle.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_cuándo_comentar">
<title>¿Cuándo comentar?</title>
<itemizedlist>
<listitem>
<simpara>Cuando tienes que pensar cómo funciona el código antes de escribirlo.</simpara>
</listitem>
<listitem>
<simpara>Cuando probablemente olvides como estabas resolviendo un problema.</simpara>
</listitem>
<listitem>
<simpara>Cuando exista más de una forma de resolver un problema.</simpara>
</listitem>
<listitem>
<simpara>Cuando es poco probable que otros comprendan cómo haz resuelto un problema.</simpara>
</listitem>
</itemizedlist>
<simpara>Escribir buenos comentarios es un indicador de un buen programador. Úsalos siempre. Verás comentarios a lo largo de los ejemplos en este documento.</simpara>
</section>
</section>
<section xml:id="_límites">
<title>Límites</title>
<itemizedlist>
<listitem>
<simpara>Máximo de 16 parámetros en una función o método.</simpara>
</listitem>
<listitem>
<simpara>Máximo de 255 propiedades en una clase (incluyendo la herencia).</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="_strings_cadena_de_caracteres">
<title><link xl:href="http://wren.io/modules/core/string.html">Strings: Cadena de caracteres</link></title>
<simpara>Las cadenas de caracteres (<emphasis>String</emphasis>) son delimitadas por las comillas dobles (<literal>"</literal>). Pueden ser de una sola línea o multi línea. En el caso de ser multi línea, estas conservarán todos los caracteres de espacio y salto de línea contenidos en el <emphasis>string</emphasis>. El caracter de comilla simple (<literal>'</literal>) no es significativo para <emphasis>Wren</emphasis>.</simpara>
<simpara>Las strings pueden contener caracteres unicode en <link xl:href="http://utf8everywhere.org/">UTF-8</link>, como también caracteres no válidos para <emphasis>UTF-8</emphasis>.</simpara>
<simpara>Además son inmutables. El string <emphasis role="strong">"porotos"</emphasis> no podrá ser modificado (cambiando sus caracteres) luego de su creación.</simpara>
<simpara>Un string puede contener los siguientes valores:</simpara>
<itemizedlist>
<listitem>
<simpara>Una cadena de texto compuesto por una secuencia de puntos de código textuales (textual code point).</simpara>
</listitem>
<listitem>
<simpara>Una cadena iterable compuesta por una secuencia de puntos de código numérico (numeric code point).</simpara>
</listitem>
<listitem>
<simpara>Un arreglo simple de bytes indexeables.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_string_de_una_línea">
<title>String de una línea</title>
<programlisting language="js" linenumbering="numbered">"Solo es necesario comillas dobles"</programlisting>
</section>
<section xml:id="_string_multi_línea">
<title>String multi línea</title>
<simpara><emphasis>Wren</emphasis> permite string multi líneas utilizando el mismo caracter de comillas dobles (<literal>"</literal>) de las strings de una sola línea.</simpara>
<programlisting language="js" linenumbering="numbered">"
 Todo esto es una string multi línea
 Wren esperará hasta que aparezca
 la siguiente comilla doble.
 Los strings multi línea en Wren guardan tanto espacios como saltos de línea en su interior.
 (no son omitidos).
"</programlisting>
</section>
<section xml:id="_contando_el_largo_del_string">
<title>Contando el largo del string</title>
<simpara>Si utilizamos la propiedad <literal>count</literal> podremos obtener el largo de un string.</simpara>
<simpara>Por ejemplo <literal>"hola".count</literal> devolverá <literal>4</literal>. Hay que tener cuidado con los caracteres unicode (emojis), ya que el largo dependerá de lo que se esté contando. <emphasis>Wren</emphasis> cuenta los puntos de código (code point) unicode, por que todos los strings están bajo <emphasis>UTF-8</emphasis> (similar al comportamiento de <link xl:href="https://www.ruby-lang.org/en/"><emphasis>Ruby</emphasis></link> y <link xl:href="https://www.python.org/"><emphasis>Python 3</emphasis></link>).</simpara>
<programlisting language="js" linenumbering="numbered">System.print("a".count) // Retorna 1.
System.print("a".bytes.count) // Retorna 1 (Parte de la tabla ASCII original).

System.print("ñ".count) // Retorna 1.
System.print("ñ".bytes.count) // Retorna 2.

System.print("👹".count) // Retorna 1.
System.print("👹".bytes.count) // Retorna 4.

System.print("👨‍👩‍👧‍👦".count) // Retorna 7 al contar la unidades de código de Unicode
System.print("👨‍👩‍👧‍👦".bytes.count) // Retorna 25 al contar los bytes UTF-8</programlisting>
<simpara><literal>System.print("👨‍👩‍👧‍👦".count)</literal> retorna 7 por que se está contando las unidades de código de unicode, es decir, el emoji 👨‍👩‍👧‍👦 está formado por los siguientes caracteres : 👨 + caracter de unión de ancho cero + 👩 + caracter de unión de ancho cero + 👧 + caracter de unión de ancho cero + 👦.</simpara>
<simpara><literal>System.print("👨‍👩‍👧‍👦".bytes.count)</literal> retorna 25 por que está contando los bytes necesarios para almacenar estos caracteres. bytes es una secuencia de caracteres en C, lo que permite utilizar los Strings para almacenar información en binario.</simpara>
<simpara>Hay dos formas de contar adicionales que <emphasis>Wren</emphasis> no soporta. La primera es contar por unidades de código <emphasis>UTF-16</emphasis> y la otra es considerar los emojis compuestos como una unidad.</simpara>
<simpara>El string "👨‍👩‍👧‍👦" debería ser de largo 11 para la codificación <emphasis>UTF-16</emphasis>. Mientras que debería ser de largo 1 si lo consideramos como un caracter singular (lo que percibe el usuario). Según los amigos de <link xl:href="http://utf8everywhere.org/">UTF-8 Everywhere</link> contar de estas formas es poco productivo, ya que lo que importa es realmente los code units (unidades de código) <emphasis>UTF-8</emphasis> que se tiene al escribir un string. Por lo que <emphasis>Wren</emphasis> tiene un comportamiento adecuado. De todas formas ese tipo de conversiones y conteo podría programarse con códigos externos a <emphasis>Wren</emphasis>. Más detalles en el <link xl:href="https://www.unicode.org/glossary/">Glosario Unicode</link>.</simpara>
</section>
<section xml:id="_unión_e_interpolación_de_strings">
<title>Unión e interpolación de strings</title>
<simpara>Si deseamos unir varios strings o incluir datos dentro de ellos podemos utilizar las siguientes operaciones: <literal>+</literal> y <literal>%()</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>"Hola" + "Wren"</literal>: Crea un nuevo string con la unión de <literal>Hola</literal> y <literal>Wren</literal>. Entregará <literal>HolaWren</literal>. Es necesario que ambos objetos sean strings. Por ejemplo si se utiliza <literal>"Hola" + 1</literal> entregará un error similar a <literal>Runtime error: Right operand must be a string.</literal>. Para poder unirlos tendremos que utiliza el método getter <literal>toString</literal> del número. <literal>"Hola" + 1.toString</literal>, retornando <literal>Hola1</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>El método <literal>toString</literal> es parte de la clase <link xl:href="http://wren.io/modules/core/object.html"><literal>Object</literal></link> la cual es la padre de todos los tipos de datos en <emphasis>Wren</emphasis>. Tanto números, booleanos, strings y listas son objetos que heredan de esta clase.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>"Hola %(mundo)"</literal>: Crea un string con la frase <literal>Hola</literal> y el contenido de la variable <literal>mundo</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>La operación <literal>%()</literal> permite incluir cualquier instrucción <emphasis>Wren</emphasis> válida, la cual finalmente ejecutará el método <literal>toString</literal> para ser incluido en la cadena de caracteres. Esto incluso permite tener interpolaciones anidadas, pero eso se vuelve poco legible rápidamente.</simpara>
<programlisting language="js" linenumbering="numbered">// muestra: La respuesta es 42.
System.print("La respuesta es %(20 * 2 + 2).")

// muestra: wow 149
System.print("wow %((1..3).map {|n| n * n}.join())")</programlisting>
</section>
<section xml:id="_multiplicación_de_strings">
<title>Multiplicación de strings</title>
<simpara>También se pueden multiplicar para repetir la cadena de caracteres una cantidad de veces determinada.</simpara>
<programlisting language="js" linenumbering="numbered">// muestra hola hola hola
System.print("hola " * 3)</programlisting>
<literallayout class="monospaced">Si bien se pueden sumar (_+_) y multiplicar (_*_), no existe operaciones para resta (_-_) y division (_/_) dentro de una cadena de caracteres.</literallayout>
</section>
<section xml:id="_limitar_el_máximo_de_caracteres">
<title>Limitar el máximo de caracteres</title>
<simpara>El <emphasis>String</emphasis> al ser una <emphasis>Secuencia</emphasis> puede utilizar
sus métodos como <emphasis>take()</emphasis> que permite obtener los
elementos dentro de una secuencia. El método <emphasis>join()</emphasis>
es necesario para convertir nuevamente la secuencia
en un <emphasis>String</emphasis>.</simpara>
<programlisting language="js" linenumbering="numbered">// muestra: hola
System.print("hola wren".take(4).join())</programlisting>
</section>
<section xml:id="_caracteres_no_imprimibles">
<title>Caracteres no imprimibles</title>
<simpara>Los caracteres no imprimibles o <emphasis>Whitespace</emphasis> son aquellos
caracteres que el computador puede ver, pero son invisibles
para una persona. Los caracteres no imprimibles más comunes son el espacio (<emphasis>" "</emphasis>), la tabulación (<emphasis>"\t"</emphasis>) y el salto de línea (<emphasis>"\n"</emphasis>). La combinación de dos caracteres <emphasis>"\t"</emphasis> crea un nuevo espacio tabulado, mientras que la combinación de dos caracteres <emphasis>"\n"</emphasis> crea una nueva línea dentro del <emphasis>String</emphasis>. ¡Puedes usarlos cuantás veces y dónde desees!.</simpara>
<simpara>Prueba el siguiente código:</simpara>
<programlisting language="js" linenumbering="numbered">System.print("Hola a todos")
System.print("\tHola a todos")
System.print("Hola\na todos")
System.print("\n\n\nHola\ta\ttodos")</programlisting>
<section xml:id="_eliminando_caracteres_no_imprimibles">
<title>Eliminando caracteres no imprimibles</title>
<simpara>Muchas veces al solicitar datos a un usuario, este puede incluir espacios adicionales al principio o final. Usualmente es buena idea eliminar estos caracteres no imprimibles antes de comenzar a procesar el dato.</simpara>
<programlisting language="js" linenumbering="numbered">var nombre = " arturo "

// Elimina solamente espacio final
System.print(nombre.trimEnd())

// Elimina solamente espacio inicial
System.print(nombre.trimStart())

// Elimina espacio inicial y final
System.print(nombre.trim())</programlisting>
<simpara>Si se necesita ver con mayor claridad lo que sucede
se puede usar el siguiente código:</simpara>
<programlisting language="js" linenumbering="numbered">var nombre = " arturo "

// Elimina solamente espacio final
System.print("-" + nombre.trimEnd() + "-")

// Elimina solamente espacio inicial
System.print("-" + nombre.trimStart() + "-")

// Elimina espacio inicial y final
System.print("-" + nombre.trim() + "-")</programlisting>
</section>
</section>
<section xml:id="_caracteres_de_escape">
<title>Caracteres de escape</title>
<simpara>Muchas veces se necesitan escribir caracteres especiales en un string. Por ejemplo si quisieramos escribir <literal>"Hola Wren"</literal> incluyendo las comillas, tendríamos que escribirlo de esta forma <literal>"\"Hola Wren\""</literal>. Esto incluirá los caracteres de comillas dobles en la frase.</simpara>
<programlisting language="js" linenumbering="numbered">"\0" // byte NUL (Nulo) : 0.
"\"" // Comillas dobles.
"\\" // Barra invertida.
"\%" // Signo porcentaje.
"\a" // Sonido de alarma.
"\b" // Retroceso.
"\f" // Alimentación de formularios.
"\n" // Salto de línea.
"\r" // Retorno de carro.
"\t" // Tabulación.
"\v" // Tabulación vertical.
"\x48"        // Byte sin codificar     (hexadecimal de 2 dígitos).
"\u0041"      // Code point Unicode (hexadecimal de 4 dígitos).
"\U0001F64A"  // Code point Unicode (hexadecimal de 8 dígitos).

// Wren 0.4 ha introducido
"\e"          // Secuencia de escape de terminal ESC.</programlisting>
<simpara>Para indicar caracteres especiales podemos utilizar <literal>\u</literal> (unicode para letras disponibles en los idiomas humanos), <literal>\U</literal> (unicode para letras especiales como emoji) y <literal>\x</literal> (bytes sin codificar).</simpara>
<itemizedlist>
<listitem>
<simpara><literal>System.print("\u0041\u0b83\u00DE")</literal> = AஃÞ</simpara>
</listitem>
<listitem>
<simpara><literal>System.print("\U0001F64A\U0001F680")</literal> = 🙊🚀</simpara>
</listitem>
<listitem>
<simpara><literal>System.print("\x48\x69\x2e")</literal> = Hi.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_raw_strings_cadenas_de_caracteres_sin_procesar">
<title><link xl:href="https://wren.io/values.html#raw-strings">Raw Strings: Cadenas de caracteres sin procesar</link></title>
<simpara>En <emphasis>Wren 0.4</emphasis> se ha introducido un nuevo tipo de <emphasis>String</emphasis> que permite utilizar las comillas sin necesidad de escaparlas.
Útil por ejemplo cuando se necesita incrustar código de otros lenguajes como <emphasis>HTML</emphasis> o <emphasis>JSON</emphasis> dentro de un script.</simpara>
<simpara>Los <emphasis>Raw Strings</emphasis> tienen todas las mismas características que un <emphasis>String</emphasis> normal. La única excepción es que no ejecutan
<emphasis role="strong">interpolación</emphasis> ni tampoco las secuencias de escape, ya que todos los caracteres son asimilados sin procesar.</simpara>
<simpara>Son delimitados por tres caracteres de doble comilla (<literal>"""</literal>). Si los delimitadores están en su propia línea los caracteres
de espaciado (<literal>\t, espacio, \n</literal>) no serán considerados. Este delimitador no se puede escapar por lo que a penas se detecte
se considerará como terminado el <emphasis>Raw String</emphasis>.</simpara>
<simpara>En el siguiente ejemplo vemos un simple <emphasis>JSON</emphasis>. Donde se puede apreciar que no es necesario escapar las comillas.</simpara>
<programlisting language="js" linenumbering="numbered">"""
  {
    "hola": "wren",
    "de" : "json"
  }
"""</programlisting>
<simpara>Podemos ver la característica de ignorar los espaciados iniciales y finales con la siguiente comparación:</simpara>
<programlisting language="js" linenumbering="numbered">// La siguiente frase tiene 8 caracteres de sangría despúes del delimitador y antes del limitador
var frase = """
        Hola Wren Raw
        """

System.print("'%(frase)'") // Mostrará Hola Wren con 8 espacios de sangría

// La siguiente frase incluye 8 caracteres de espacio
frase = "
        Hola Wren
        "

System.print("'%(frase)'") // Muestra Hola Wren con 24 espacios de sangría</programlisting>
<simpara>Dando el siguiente resultado (se han agregado comillas para mostrar cuando comienza y termina un resultado):</simpara>
<programlisting language="txt" linenumbering="numbered">'        Hola Wren Raw'
'
        Hola Wren
        '</programlisting>
<section xml:id="_incluyendo_el_delimitador_dentro_de_un_raw_string">
<title>Incluyendo el delimitador dentro de un <emphasis>Raw String</emphasis></title>
<simpara>Debido a que el delimitador no se puede escapar. Para incluirlo se debe utilizar la concatenación de <emphasis>Strings</emphasis> o utilizando
el método <literal>replace</literal>.</simpara>
<simpara>Concatenación de <emphasis>String</emphasis>.</simpara>
<programlisting language="js" linenumbering="numbered">System.print(""" mi raw string """ + "\"\"\"")</programlisting>
<simpara>Utilizando <literal>replace</literal></simpara>
<programlisting language="js" linenumbering="numbered">System.print(""" mi raw string '''""".replace("'", "\""))</programlisting>
<simpara>Ambos darán el siguiente resultado:</simpara>
<programlisting language="txt" linenumbering="numbered">mi raw string """</programlisting>
</section>
</section>
<section xml:id="_rangos_de_caracteres">
<title>Rangos de caracteres</title>
<simpara>Un <emphasis>String</emphasis> es una <emphasis>Secuencia</emphasis> de caracteres. Por lo que es posible obtener caracteres en posiciones específicas
utilizando rangos (<emphasis>Range</emphasis>). El índice comieza contando
desde cero para contar desde el principio de la cadena y puede tener valores negativos para contar
desde el final de la cadena.</simpara>
<section xml:id="_caracter_en_posición_específica">
<title>Caracter en posición específica</title>
<programlisting language="js" linenumbering="numbered">// muestra: h
System.print("hola wren"[0])

// muestra: n
System.print("hola wren"[-1])</programlisting>
</section>
<section xml:id="_rango_de_caracteres_dentro_de_una_cadena">
<title>Rango de caracteres dentro de una cadena</title>
<programlisting language="js" linenumbering="numbered">// muestra: la
System.print("hola wren"[2..3])</programlisting>
</section>
<section xml:id="_invertir_una_cadena_de_caracteres">
<title>Invertir una cadena de caracteres</title>
<programlisting language="js" linenumbering="numbered">// muestra: nerw aloh
System.print("hola wren"[-1..0])</programlisting>
</section>
<section xml:id="_eliminando_sangría_sobrante">
<title><link xl:href="https://github.com/wren-lang/wren/wiki/%5BCookbook%5D-Trim-String-Indent">Eliminando Sangría Sobrante</link></title>
<simpara>En muchas ocasiones nos encontramos con la necesidad de eliminar la sangría que se genera al escribir código.
Para esto podemos utilizar la siguientes funciones:</simpara>
<programlisting language="js" linenumbering="numbered">var contar_sangria = Fn.new {|string|
    var indice = 0
    var bytes = string.bytes
    while(indice &lt; bytes.count) {
        var caracter = bytes[indice]
        if(caracter == 0x20 || caracter == 0x09) {
          indice = indice + 1
          continue
        }
        return indice
    }
    return 0
}

var borrar_sangrado = Fn.new {|string|
    var inicio = contar_sangria.call(string)
    if(inicio == 0) return string
    var lineas = string.split("\n")

    lineas = lineas.map {|linea|
        var izquierda = contar_sangria.call(linea)
        if(izquierda &gt;= inicio) return linea[inicio..-1]
        return linea
    }
    return lineas.join("\n")
}</programlisting>
<simpara>Ejemplo de uso:</simpara>
<programlisting language="js" linenumbering="numbered">// Ejemplo
var frase = """        Mucha Sangría"""

// Elimina la sangría de la frase
System.print(borrar_sangrado.call(frase))</programlisting>
</section>
</section>
<section xml:id="_ejercicios_2">
<title>Ejercicios</title>
<section xml:id="chap3-ex1">
<title>Donas</title>
<simpara>Dada una cantidad de un número de donas,
retornar un string con el contenido
<emphasis>"Número de donas: &lt;cantidad&gt;"</emphasis>. Si
la cantidad es mayor o igual a 10, usar
la palabras <emphasis>'muchas'</emphasis> en vez del número de cantidad.</simpara>
<simpara>Ejercicio basado en <xref linkend="googlepython"/>.</simpara>
<formalpara>
<title>Ejecución</title>
<para><literal>$ ./wren donas.wren</literal></para>
</formalpara>
<itemizedlist>
<title>Ejemplo</title>
<listitem>
<simpara><literal>donas.call(5)</literal> retorna <emphasis>"Número de donas: 5"</emphasis></simpara>
</listitem>
<listitem>
<simpara><literal>donas.call(23)</literal> retorna <emphasis>"Número de donas: muchas"</emphasis></simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Código</title>
<para>
<programlisting language="js" linenumbering="numbered">var donas = Fn.new {|cantidad|
  // Tu código aquí
}


// Pruebas para evaluar que el ejercicio
// se ha completado exitosamente.
// no modificar.

var probar = Fn.new {|tengo, quiero|
  var prefijo = " X "
  if (tengo == quiero) {
    prefijo = " OK "
  }
  System.print("%(prefijo) tengo: %(tengo) quiero: %(quiero)")
}

System.print("Probando donas")
probar.call(donas.call(4), "Número de donas: 4")
probar.call(donas.call(9), "Número de donas: 9")
probar.call(donas.call(10), "Número de donas: muchas")
probar.call(donas.call(99), "Número de donas: muchas")
System.print()</programlisting>
</para>
</formalpara>
<formalpara>
<title>Solución</title>
<para><xref linkend="chap3-ex1-sol"/></para>
</formalpara>
</section>
</section>
</chapter>
<chapter xml:id="_num_números">
<title><link xl:href="https://wren.io/modules/core/num.html">Num: Números</link></title>
<simpara>Los datos numéricos son bastante conocidos, sin embargo hay algunas cosas que se deben tener en cuenta. Como la mayoría de los lenguajes interpretados, <emphasis>Wren</emphasis> tiene un único tipo numérico: punto flotante de doble precisión. Los números en <emphasis>Wren</emphasis> son similares a otros lenguajes y son instancias de la clase <emphasis>Num</emphasis>.</simpara>
<simpara>Los siguientes son algunos ejemplos:</simpara>
<programlisting language="js" linenumbering="numbered">// Enteros
0
1234
-5678

// Decimales
3.14159
1.0
-12.34

// Notación científica
0.0314159e02
314.159e-02</programlisting>
<section xml:id="_enteros">
<title>Enteros</title>
<simpara>Se pueden realizar todas las operaciones tradicionales con números enteros. Suma (<emphasis>+</emphasis>), resta (<emphasis>-</emphasis>), multiplicación (<emphasis>*</emphasis>), división (<emphasis>/</emphasis>) y módulo (<emphasis>%</emphasis>). Para utilizar exponentes se debe usar el método <emphasis>pow()</emphasis>.</simpara>
<programlisting language="js" linenumbering="numbered">System.print(3+2)

System.print(3-2)

System.print(3*2)

System.print(3/2)

System.print(3%2)

System.print(3.pow(2))</programlisting>
<simpara>También se puede utilizar paréntesis para alterar el orden de las operaciones.</simpara>
<programlisting language="js" linenumbering="numbered">var ordenNormal = 2+3*4

System.print(ordenNormal)

var ordenMio = (2+3)*4

System.print(ordenMio)</programlisting>
</section>
<section xml:id="_punto_flotante">
<title><link xl:href="https://github.com/Pybonacci/puntoflotante.org">Punto Flotante</link></title>
<simpara>Los números de punto flotante se refieren a cualquier número con una parte decimal. La mayoría del tiempo se comportan de una forma matemática tradicional. Pero en muchas ocaciones se obtienen resultados con una parte decimal más larga de lo esperado. Esto ocurre por como las computadoras representan los números internamente; no tiene que ver con <emphasis>Wren</emphasis> mismo. Básicamente, los humanos están acostumbrados a trabajar con números <emphasis>base 10</emphasis>, donde <emphasis>0.1</emphasis> + <emphasis>0.2</emphasis> = <emphasis>0.3</emphasis>. Pero las computadoras trabajan en <emphasis>base 2</emphasis> y expresan los resultados como una potencia de dos. No existe una representación exacta para <emphasis>0.3</emphasis> en una potencia de dos y por esa razón el resultado presenta tantos decimales.</simpara>
<simpara>Como la memoria de las computadoras es limitada, no pueden almacenar números
con precisión infinita, en algún momento se debe limitar. Pero ¿Cuánta precisión se necesita?
¿Y <emphasis>dónde</emphasis> se necesita?, ¿Cuántos dígitos enteros y cuántos fraccionarios?</simpara>
<itemizedlist>
<listitem>
<simpara>Para un ingeniero construyendo una autopista, no importa si tiene 10 metros o 10.0001 metros de ancho ─ posiblemente ni siquiera sus mediciones eran así de precisas.</simpara>
</listitem>
<listitem>
<simpara>Para alguien diseñando un microchip, 0.0001 metros (la décima parte de un milímetro) es una diferencia <emphasis>enorme</emphasis> ─ pero nunca tendrá que manejar distancias mayores de 0.1 metros.</simpara>
</listitem>
<listitem>
<simpara>Un físico necesita usar la <link xl:href="http://es.wikipedia.org/wiki/Velocidad_de_la_luz">velocidad de la luz</link> (más o menos 300000000) y la <link xl:href="http://es.wikipedia.org/wiki/Constante_de_gravitaci%C3%B3n_universal">constante de gravitación universal</link> (más o menos 0.0000000000667) juntas en el mismo cálculo.</simpara>
</listitem>
</itemizedlist>
<simpara>Para satisfacer al ingeniero y al diseñador de circuitos integrados, el formato
tiene que ser preciso para números de órdenes de magnitud muy diferentes. Sin
embargo, solo se necesita precisión <emphasis>relativa</emphasis>. Para satisfacer al físico, debe
ser posible hacer cálculos que involucren números de órdenes muy dispares.</simpara>
<simpara>Básicamente, tener un número fijo de dígitos enteros y fraccionarios no es útil ─ y la solución es un formato con un <emphasis>punto flotante</emphasis>.</simpara>
<section xml:id="_comparación_de_punto_flotante">
<title>Comparación de Punto Flotante</title>
<simpara>Si realizamos una pequeña comparación de números con punto flotante, nos encontraremos con que algunas comparaciones simples no pueden ser realizadas correctamente de la forma tradicional.</simpara>
<simpara>Debido a los errores de redondeo, la mayoría de los números de punto flotante terminan siendo ligeramente imprecisos. Mientras esta imprecisión se mantenga pequeña, normalmente se puede ignorar. Sin embargo, esto significa también que números que se espera que sean iguales (por ejemplo al calcular el mismo resultado utilizando distintos métodos correctos) a veces difieren levemente, y una simple prueba de igualdad falla:</simpara>
<programlisting language="js" linenumbering="numbered">var a = 0.15 + 0.15
var b = 0.1 + 0.2

// puede ser falso
if (a == b) {}

// también puede ser falso
if (a &gt;= b) {}</programlisting>
<simpara>Como los números de punto flotante tienen una cantidad de dígitos limitados, no pueden representar todos los <link xl:href="http://es.wikipedia.org/wiki/N%C3%BAmero_real">números reales</link> de forma precisa: cuando hay más dígitos de los que permite el formato, los que sobran se omiten.</simpara>
<simpara>La solución es comprobar no si los números son exactamente iguales, sino si su <emphasis>diferencia es muy pequeña</emphasis>. El margen de error frente al que se compara esta diferencia normalmente se llama <emphasis>epsilon</emphasis>.</simpara>
<simpara>El valor de <emphasis>epsilon</emphasis> dependerá del contexto. Nunca usar un <emphasis>epsilon</emphasis> fijo. Un <emphasis>epsilon</emphasis> fijo elegido porque «parece pequeño» podría perfectamente ser demasiado grande cuando los números que se comparan son también muy pequeños. La comparación devolvería «verdadero» para números muy diferentes. Y cuando los números son muy grandes, el <emphasis>epsilon</emphasis> puede acabar siendo más pequeño que el mínimo error de redondeo, por lo que la comparación siempre devolvería «falso». Por tanto, es necesario ver si el error relativo es menor que <emphasis>epsilon</emphasis>.</simpara>
<simpara>El código a continuación pasa las pruebas para muchos casos especiales importantes, pero como puedes ver, utiliza cierta lógica no trivial. En particular, tiene que utilizar una definición totalmente distinta del margen de error cuando a o b son cero, porque la definición clásica del error relativo es inútil en esos casos.</simpara>
<simpara>Hay algunos casos en los que todavía produce resultados inesperados (concretamente, es mucho más estricto cuando un valor es casi cero que cuando es exactamente cero), y algunas de esas pruebas para las que fue desarrollado probablemente especifica un comportamiento que no es apropiado para algunas aplicaciones. Antes de usarlo, ¡asegúrate de que es adecuado para tu aplicación!.</simpara>
<programlisting language="js" linenumbering="numbered">var equivalentes = Fn.new { |a, b, epsilon|

  var absA = a.abs
  var absB = b.abs
  var diff = (a - b).abs

  // Atajo, maneja los infinitos
  if (a == b) {
      return true
  }

  // a o b o ambos son cero
  if (a * b == 0) {
      // El error relativo no es importante aquí.
      // Se tiene que utilizar una definición totalmente distinta
      // del margen de error cuando a o b son cero, porque la definición
      // clásica del error relativo es inútil en esos casos.
      return diff &lt; (epsilon * epsilon)
  }

  // Usar el error relativo
  return diff / (absA + absB) &lt; epsilon
}

// Prueba de la función
var a = 0.15 + 0.15
var b = 0.1 + 0.2

// Epsilon siempre debe ser entregado según el contexto de comparación
// no utilizar epsilon fijos.
var epsilon = 0.001

var eq = equivalentes.call(a, b, epsilon)

// Debería ser verdadero
System.print(eq)</programlisting>
</section>
<section xml:id="_formateo_de_punto_flotante">
<title>Formateo de Punto Flotante</title>
<simpara>En muchas ocaciones se necesita limitar la cantidad
de decimales que un número muestra. <emphasis>Wren</emphasis> no cuenta
con instrucciones para formatear números como <emphasis>C</emphasis> u otros lenguajes (Ejemplo: <link xl:href="http://www.cplusplus.com/reference/cstdio/printf/"><emphasis>"%1.2f"</emphasis></link>.)</simpara>
<simpara>Sin embargo existen algunas alternativas.</simpara>
<simpara>Tomemos por ejemplo la constante <emphasis>PI</emphasis> (<literal>Num.pi</literal>) =~ <emphasis>3.141592</emphasis>.</simpara>
<simpara>Si solamente quisieramos mostrar la parte entera (<emphasis>3</emphasis>) podemos utilizar el método <emphasis>truncate</emphasis>.</simpara>
<programlisting language="js" linenumbering="numbered">// Solamente muestra 3
System.print(Num.pi.truncate)</programlisting>
<simpara>Si desearamos mostrar <emphasis>3.14</emphasis> podemos usar la siguiente fórmula.</simpara>
<simpara><literal>(numero * 1e&lt;posiciones decimales&gt;).truncate / 1e&lt;posiciones decimales&gt;</literal></simpara>
<programlisting language="js" linenumbering="numbered">var formateado = (Num.pi * 1e2).truncate / 1e2

// Muestra 3.14
System.print(formateado)</programlisting>
<simpara>Podemos crear una función que generalice esta fórmula a cualquier cantidad de decimales.</simpara>
<programlisting language="js" linenumbering="numbered">var formatear = Fn.new {|numero, decimales| (numero * 10.pow(decimales)).truncate / 10.pow(decimales)}

// Muestra 3.14
System.print(formatear.call(Num.pi, 2))</programlisting>
<simpara>El problema de esta solución es que existe la posibilidad de perder precisión en los decimales, lo que puede causar problemas de cálculo. Para evitar este problema la solución recomendable es transformar el número a <emphasis>String</emphasis> y obtener los decimales por medio de manipulación de <emphasis>strings</emphasis>.</simpara>
<programlisting language="js" linenumbering="numbered">// Convertimos el número a String
var string = Num.pi.toString

// Queremos mostrar 3.14
var posiciones = 2

// Buscamos donde comienzan los decimales
var index = string.indexOf(".")

// Separamos el número entre entero y decimal
var entero = string[0...index]
var decimal = string[index + 1..-1]

// Obtenemos los decimales a mostrar
var decimales = decimal.take(posiciones).join()

// Reunimos la parte entera y decimal
var formateado = entero + "." + decimales

System.print(formateado)</programlisting>
</section>
</section>
<section xml:id="_0_y_0">
<title><link xl:href="https://github.com/wren-lang/wren/issues/1052">0 y -0</link></title>
<simpara>Un asunto interesante es la representación del número cero <literal>0</literal> y cero negativo <literal>-0</literal>.
Para <emphasis>Wren</emphasis> ambos valores son tratados como iguales, aún cuando su representación es diferente a nivel de bits.
Pero solo aplica si se realiza la comparación utilizando el operador <literal>==</literal>. Si se utiliza <literal>Object.same()</literal> retornará
falso debido a que son objetos distintos.</simpara>
<programlisting language="js" linenumbering="numbered">System.print(0 == -0)            // true (verdadero)
System.print(Object.same(0, -0)) // false (falso)</programlisting>
<simpara>Es importante considerar cuando se esté utilizando índices para acceder a los datos
de un arreglo o un diccionario (mapa).</simpara>
<programlisting language="js" linenumbering="numbered">var cero = 0
var cerone = -0

var mapa = {
  cero: 1
}

System.print(cero == cerone) // true (verdadero)
System.print(mapa[cerone]) // null (nulo)</programlisting>
<simpara>En el anterior código <literal>mapa[cerone]</literal> devuelve nulo debido a que el índice <literal>-0</literal> no existe.</simpara>
</section>
</chapter>
<chapter xml:id="_secuencias_listas_y_rangos">
<title>Secuencias, Listas y Rangos</title>
<section xml:id="_sequence_secuencias">
<title><link xl:href="https://wren.io/modules/core/sequence.html">Sequence: Secuencias</link></title>
<simpara>La secuencia es la clase padre de <emphasis>List</emphasis>, <emphasis>String</emphasis>, <emphasis>Map</emphasis>, <emphasis>Range</emphasis> y cualquier otra que implemente el <link xl:href="https://wren.io/control-flow.html#the-iterator-protocol"><emphasis>protocolo de iteración</emphasis></link>. La característica principal de una secuencia es que esta podría ser virtualmente infinita (sin elementos que indiquen un fin).
Entre los métodos que podemos destacar de <emphasis>Sequence</emphasis> están:</simpara>
<section xml:id="_each">
<title>each</title>
<simpara>Similar a un bucle <literal>for</literal>. Por cada elemento dentro de la secuencia llama a una función cuyo parámetro es el siguiente elemento en la secuencia.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3]
numeros.each {|num|
  System.print(num)
}</programlisting>
</section>
<section xml:id="_map">
<title>map</title>
<simpara>Llama a una función cuyo parámetro es el siguiente elemento en la secuencia. Retorna una nueva secuencia con el resultado de las operación en cada elemento.
El resultado de <literal>map</literal> es almacenado por referencia. Lo que significa que cambios posteriores en la secuencia original pueden afectar el valor del resultado de <literal>map</literal>.
Para pasarlo a una variable independiente, se debe ejecutar el método <literal>toList</literal>.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3]

// .toList es necesario para que System.print() muestre la lista apropiadamente.
// Esto es debido a que una secuencia puede no tener fin. Necesitamos pasarlo a una estructura de datos finita.
// También estamos utilizando el "retorno implícito".
numeros = numeros.map{|num| num + 1}.toList

// Muestra [2, 3, 4]
System.print(numeros)</programlisting>
</section>
<section xml:id="_where">
<title>where</title>
<simpara>Filtra una secuencia. Entregará una nueva lista la cual cumpla la condicional. Al igual que <literal>map</literal> se debe ejecutar el método <literal>toList</literal> para evitar que modificaciones en la secuencia original afecten la nueva secuencia.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3, 4]

var pares = numeros.where{|num| num % 2 == 0}.toList

// Muestra [2, 4]
System.print(pares)</programlisting>
</section>
<section xml:id="_reduce">
<title>reduce</title>
<simpara>Llama a una función cuyo parámetro es el siguiente elemento en al secuencia. Retorna un único elemento, producto de las operaciones en cada elemento.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3]

// Si no se pasa un acumulador, se considera el primer elemento como valor inicial
var resultado = numeros.reduce {|acumulador, num| acumulador + num}

// Muestra 6
System.print(resultado)

// Iniciamos el acumulador con valor -1
resultado = numeros.reduce(-1) {|acumulador, num| acumulador + num}

// Muestra 5
System.print(resultado)</programlisting>
</section>
<section xml:id="_take">
<title>take</title>
<simpara>Obtiene un número de elementos dentro de una secuencia.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3, 4]
var primeros = numeros.take(2).toList

// Muestra [1, 2]
System.print(primeros)</programlisting>
</section>
<section xml:id="_skip">
<title>skip</title>
<simpara>La operación inversa de <literal>take</literal>. Salta un número determinado de elementos.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3, 4]
var ultimos = numeros.skip(2).toList

// Muestra [3, 4]
System.print(ultimos)</programlisting>
</section>
<section xml:id="_contains">
<title>contains</title>
<simpara>Retorna verdadero si la secuencia contiene al elemento.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3]

// Muestra "false" debido a que no contiene el número 4
System.print(numeros.contains(4))</programlisting>
</section>
<section xml:id="_count">
<title>count</title>
<simpara>Retorna el número de elementos de la secuencia. También es posible solamente contar elementos que cumplan una condición.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3, 4]

// 4
System.print(numeros.count)

// Contamos solamente los números múltiplos de 2
var pares = numeros.count {|num| num % 2 == 0}

// 2
System.print(pares)</programlisting>
</section>
<section xml:id="_join">
<title>join</title>
<simpara>Une a los elementos de una secuencia transformándolos en un <emphasis>String</emphasis>. Si no se pasa un parámetro se asume un caracter vació como unión.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3]

// Muestra "123"
System.print(numeros.join())

// Muestra "1$2$3"
System.print(numeros.join("$"))

// Muestra "1 num 2 num 3"
System.print(numeros.join(" num "))</programlisting>
</section>
<section xml:id="_all">
<title>all</title>
<simpara>Itera sobre los elementos de una secuencia con una condicional. Devuelve verdadero si todos los elementos pasan la condición.
Si alguno de los elementos es falso, termina de iterar y devuelve falso.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3]
var resultado = numeros.all {|num| num &gt; 2}

// Falso. No todos los números en la secuencia son mayores a 2
System.print(resultado)

resultado = numeros.all{|num| num &lt; 4}

// Verdadero. Todos los números en la secuencia son menores a 4
System.print(resultado)</programlisting>
</section>
<section xml:id="_any">
<title>any</title>
<simpara>Similar a <literal>all</literal>. Devuelve verdadero al primer elemento que pase la condición. Si ninguno de los elementos pasa la condición, devuelve falso.</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3]
var resultado = numeros.any {|num| num % 2 == 0}

// Verdadero. Existe un número múltiplo de 2.
System.print(resultado)

resultado = numeros.any {|num| num % 5 == 0}

// Falso. Ningún número es múltiplo de 5.
System.print(resultado)</programlisting>
</section>
<section xml:id="_ejemplo">
<title>ejemplo</title>
<simpara>El siguiente ejemplo utiliza algunas funciones de <literal>Sequence</literal> para obtener el primer elemento
de una secuencia dependiendo de una condición.</simpara>
<programlisting language="js" linenumbering="numbered">  // Creamos una nueva función para nuestra lógica
  var primerElemento = Fn.new {|elementos, predicado|

    // Si existe un elemento que cumpla la condición, obtenemos el primero de la secuencia.
    var resultado = elementos.any(predicado) ? elementos.where(predicado).take(1) : false
    if (resultado &amp;&amp; resultado.count &gt; 0) {
      return resultado.toList[0]
    }

    // Caso contrario devolvemos nulo
    return null
  }

  var numeros = [1, 2, 3]
  var resultado = primerElemento.call(numeros) {|item| item &gt; 1}

  // Muestra 2
  System.print(resultado)

  resultado = primerElemento.call(numeros) {|item| item &gt; 3}

  // Muestra null
  System.print(resultado)</programlisting>
</section>
</section>
<section xml:id="_subscripts_subíndices">
<title><link xl:href="https://wren.io/method-calls.html#subscripts">Subscripts: Subíndices</link></title>
<simpara>Los <emphasis>Subíndices</emphasis> nos ayudan a obtener valores dentro de una lista, mapa u objeto que implemente
el método de subíndice utilizando los paréntesis cuadrados (corchetes) <literal>[]</literal>.</simpara>
<programlisting language="js" linenumbering="numbered">lista[0]    // Obtiene el primer elmento de la lista
mapa["id"] // Obtiene el valor asociado con "id"</programlisting>
<simpara>El siguiente código muestra como implementar un objeto que acepta dos parámetros en su método de subíndice.</simpara>
<programlisting language="js" linenumbering="numbered">class Matriz {
  [x, y] {"x %(x), y %(y)"}
  construct nueva() {}
}

var matriz = Matriz.nueva()

// Muestra x 1 y 1
System.print(matriz[1,1])</programlisting>
</section>
<section xml:id="_list_listas">
<title><link xl:href="https://wren.io/modules/core/list.html">List: Listas</link></title>
<simpara>Una lista es una colección de elementos que son almacenados en una variable. Los elementos pueden estar relacionados de cierta forma o no tener ningún tipo de relación.</simpara>
<simpara>El siguiente ejemplo muestra algunas operaciones disponibles para listas:</simpara>
<programlisting language="js" linenumbering="numbered">var estudiantes = ["Pedro", "Javier", "Nicolás"]

// Iteramos sobre los elementos de la lista
for (estudiante in estudiantes) {
    System.print("¡Hola, " + estudiante + "!")
}

// La misma operación anterior, pero utilizando la función each
estudiantes.each{|estudiante|
  System.print("¡Hola, " + estudiante + "!")
}

// Añadimos un nuevo estudiante en la última posición
estudiantes.add("Juan")

// Muestra ["Pedro", "Javier", "Nicolás", "Juan"]
System.print(estudiantes)

// Muestra "false" por que no existe el estudiante María
System.print(estudiantes.contains("María"))

// Muestra ["Pedro", "Javier"]
System.print(estudiantes.take(2).toList)

// Insertamos un nuevo elemento en la última posición disponible
estudiantes.insert(estudiantes.count - 1, "Javier Manzana")

// Filtramos todos los estudiantes que se llamen Javier
// Muestra: ["Javier", "Javier Manzana"]
System.print(estudiantes.where {|nombre| nombre.startsWith("Javier")}.toList)

// Elimina todos los estudiantes
estudiantes.clear()</programlisting>
<programlisting language="js" linenumbering="numbered">// Generamos una lista de 4 elementos con valor 1
var elementos = [1] * 4

// Muestra [1, 1, 1, 1]
System.print(elementos)</programlisting>
<simpara>También podemos combinar listas fácilmente</simpara>
<programlisting language="js" linenumbering="numbered">var numeros = [1, 2, 3]
var letras = ["a", "b", "c"]
var elementos = numeros + letras

// Muestra [1, 2, 3, a, b, c]
System.print(elementos)</programlisting>
</section>
<section xml:id="_range_rangos">
<title><link xl:href="https://wren.io/modules/core/range.html">Range: Rangos</link></title>
<simpara>Un rango es un objeto que representa una lista finita, incremental e iterable de números.
Es una operación disponible en cada instancia de un número.
Es dada por la operación <literal>..</literal> y la operación <literal>&#8230;&#8203;</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>inicio..fin</literal>: Incluye al número <literal>fin</literal>. Ejemplo: <literal>1..3</literal> retorna <literal>[1, 2, 3]</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>inicio&#8230;&#8203;fin</literal>: No incluye al número <literal>fin</literal>. Ejemplo <literal>1&#8230;&#8203;3</literal> retorna <literal>[1, 2]</literal>.</simpara>
</listitem>
</itemizedlist>
<programlisting language="js" linenumbering="numbered">// Mostramos los números del 1 al 5
(1..5).each {|num|
  System.print("Número %(num)")
}</programlisting>
<programlisting language="js" linenumbering="numbered">// Mostramos del 3 al 1
((1 + 2)..(3 - 2)).each {|num|
  System.print("Número %(num)")
}</programlisting>
<programlisting language="js" linenumbering="numbered">// Mostramos del 1 al 3 utilizando bucle for.
for (num in 1..3) {
  System.print("Número %(num)")
}</programlisting>
<simpara>Los rangos son muy útiles para obtener subconjuntos dentro de objetos iterables
como <emphasis>Strings</emphasis> y <emphasis>Lists</emphasis>.</simpara>
<programlisting language="js" linenumbering="numbered">var nombre = "Juanito"

// Muestra "nito"
System.print(nombre[3..-1])

// Muestra "otinauJ"
System.print(nombre[-1..0])</programlisting>
<programlisting language="js" linenumbering="numbered">var letras = ["a", "b", "c", "d", "e"]
var subconjunto = letras[1..3]

// Muestra [b, c, d]
System.print(subconjunto)</programlisting>
</section>
</chapter>
<chapter xml:id="_funciones_y_fibras">
<title>Funciones y Fibras</title>
<simpara>Uno de los principios de los lenguajes de programación es evitar código repetitivo (<emphasis>Don&#8217;t Repeat Yourself</emphasis>). Si una acción se debe ejecutar más de una vez se puede definir esa acción una única vez y luego reutilizarla cuantas veces se necesite.
Hay lenguajes de programación como <link xl:href="https://elixir-lang.org/">Elixir</link> que son solamente funciones. Por lo que son una herramienta
muy poderosa.</simpara>
<simpara>Las funciones y fibras permiten reducir el trabajo necesario y su uso efectivo permite un código con menor cantidad de errores.
En escencia son un conjunto de acciones que están agrupadas.</simpara>
<section xml:id="_functions_funciones">
<title><link xl:href="https://wren.io/functions.html">Functions: Funciones</link></title>
<simpara>En <emphasis>Wren</emphasis> las funciones son objetos, esto significa que son iguales que cualquier otra variable y pueden ser usadas como
parámetros al igual que un <emphasis>String</emphasis> o un número. Otros lenguajes como <emphasis>Java</emphasis> no tienen esta característica.</simpara>
<simpara>En el sentido matemático podemos tener la siguiente expresión:</simpara>
<programlisting language="txt" linenumbering="numbered">f(x) = (x + 10) / 2</programlisting>
<simpara>Podemos interpretarla como</simpara>
<programlisting language="txt" linenumbering="numbered">y = (x + 10) / 2</programlisting>
<simpara>Lo cual puede ser expresado en <emphasis>Wren</emphasis> de la siguiente forma:</simpara>
<programlisting language="js" linenumbering="numbered">var y = Fn.new {|x| (x + 10) / 2}</programlisting>
<simpara>Como se puede apreciar una función está definida por la clase <literal>Fn</literal>.
Se llama al método <literal>new</literal> para crear una nueva función.
El cuerpo de la función está definido por las llaves <literal>{}</literal>.
Los parámetros están definidos entre las barras <literal>||</literal>.</simpara>
<simpara>Para poder ejecutar la función y obtener su resultado, basta simplemente
con utilizar el método <literal>call</literal>.</simpara>
<programlisting language="js" linenumbering="numbered">var y = Fn.new {|x| (x + 10) / 2}
var resultado = y.call(10) // x valdría 10
System.print(resultado) // muestra: 10</programlisting>
<section xml:id="_recursividad">
<title>Recursividad</title>
<simpara>Podemos llamar a una función de forma recursiva, sin embargo
se debe declarar la variable antes de poder referenciarla.</simpara>
<simpara>El siguiente ejemplo muestra la implementación del algoritmo de <link xl:href="https://es.wikipedia.org/wiki/B%C3%BAsqueda_binaria">búsqueda binaria (Binary Search)</link>.</simpara>
<programlisting language="js" linenumbering="numbered">// Declaramos la variable
var buscar

// Le asignamos el contenido
buscar = Fn.new {|elementos, objetivo, minimo, maximo|
    if (maximo &lt; minimo) {
      return -1
    }

    var posicion = ((maximo + minimo) / 2).round
    var candidato = elementos[posicion]

    if (candidato == objetivo) {
      return posicion
    }

    if (candidato &gt; objetivo) {
      // Ahora podemos hacer una llamada recursiva
      return buscar.call(elementos, objetivo, minimo, posicion - 1)
    }

    return buscar.call(elementos, objetivo, posicion + 1, maximo)
}

var elementos = (0..30).toList
var minimo = 0
var maximo = elementos.count - 1

System.print(buscar.call(elementos, 30, minimo, maximo)) // 30
System.print(buscar.call(elementos, 31, minimo, maximo)) // -1
System.print(buscar.call(elementos, 20, minimo, maximo)) // 20</programlisting>
<simpara>Si no se declara la variable podría aparecer un error similar a:</simpara>
<blockquote>
<simpara>[./scratch line 57] Error at '}': Variable 'buscar' referenced before this definition (first use at line 53).</simpara>
</blockquote>
</section>
</section>
<section xml:id="_fibers_fibras">
<title><link xl:href="https://wren.io/concurrency.html">Fibers: Fibras</link></title>
<simpara>Las fibras son similares a las funciones, pero tienen la característica de que pueden ser
pausadas y re-ejecutadas a voluntad. Esto es especialmente útil para obtener concurrencia,
es decir, ejecutar varias operaciones de forma paralela.</simpara>
<simpara>Todas las fibras en <emphasis>Wren</emphasis> son manejadas por la máquina virtual de <emphasis>Wren</emphasis>. Lo cual es excelente
ya que no dependerá del sistema operativo para gatillar nuevos procesos, permitiendo ahorrar recursos.</simpara>
<simpara>En el siguiente ejemplo podemos ver como pausar y re-ejecutar una fibra.</simpara>
<programlisting language="js" linenumbering="numbered">var fibra = Fiber.new {
  (1..4).each {|num|
    // Pausa la fibra y devuelve un valor
    Fiber.yield(num)
  }
}

System.print(fibra.call()) // muestra: 1

// Podemos ejecutar otras instrucciones y continuar la fibra
System.print(fibra.call()) // muestra: 2

// También podemos pasar un valor como parámetro adicional
System.print(fibra.call(10)) // muestra: 3

System.print(fibra.call()) // muestra: 4
System.print(fibra.call()) // muestra: null</programlisting>
<simpara>En una función esto no es posible ya que solo tendríamos acceso al último valor calculado.</simpara>
<programlisting language="js" linenumbering="numbered">var funcion = Fn.new {
  var numero = null
  (1..4).each{|num|
    numero = num
  }
  return numero
}

System.print(funcion.call()) // muestra: 4</programlisting>
<section xml:id="_manejo_de_errores">
<title><link xl:href="https://wren.io/error-handling.html">Manejo de Errores</link></title>
<simpara>En muchos lenguajes se utiliza una secuencia llamada <literal>try-catch</literal>. En <emphasis>Wren</emphasis> las fibras
son las encargadas de manejar los errores en tiempo de ejecución.</simpara>
<simpara>Utilizando el método <literal>try</literal> podemos ejecutar una fibra y capturar el error.</simpara>
<programlisting language="js" linenumbering="numbered">var fibra = Fiber.new {
  123.noExiste
}

var error = fibra.try()
System.print("Hubo un Error: " + error)</programlisting>
<simpara>Si deseamos generar un error propio podemos utilizar <literal>Fiber.abort()</literal>.</simpara>
<simpara>Este error puede ser un mensaje normal.</simpara>
<programlisting language="js" linenumbering="numbered">Fiber.abort("Hubo un error")</programlisting>
<simpara>O también un objeto personalizado.</simpara>
<programlisting language="js" linenumbering="numbered">class MiError {
  construct nuevo() {}
  mensaje {"Este es un objeto error personalizado"}
}

var fibra = Fiber.new {
  Fiber.abort(MiError.nuevo())
}

fibra.try()

if (fibra.error is MiError) {
  System.print(fibra.error.mensaje)
}</programlisting>
</section>
</section>
</chapter>
<chapter xml:id="_control_de_flujo_2">
<title>Control de Flujo</title>
<simpara>El control de flujo permite modificar la normal ejecución de un programa,
cambiando su curso dependiendo de condiciones específicas.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>if</literal>: (sí) permite ejecutar un bloque de código solamente si la condición es cumplida.</simpara>
</listitem>
<listitem>
<simpara><literal>for</literal>: (repetir) permite ejecutar un bloque de código tantas veces como el contador y la condicional permitan.</simpara>
</listitem>
<listitem>
<simpara><literal>while</literal> (mientras) permite ejecutar un bloque de código siempre que la condición se cumpla.</simpara>
</listitem>
</itemizedlist>
<programlisting language="js" linenumbering="numbered">var numero = 8
if (numero % 2 == 0) {
  System.print("El número es par")
}</programlisting>
<programlisting language="js" linenumbering="numbered">for(i in 1..3) {
  /*
  Paso 1
  Paso 2
  Paso 3
  */
  System.print("Paso " + i.toString)
}</programlisting>
<programlisting language="js" linenumbering="numbered">/*
comienza
paso 1
paso 2
paso 3
finalizado
*/
var verdadero = true
var contador = 1
System.print("comienza")
while(verdadero) {
  System.print("paso " + contador.toString)
  if (contador == 3) {
    verdadero = false
    System.print("finalizado")
  }

  contador = contador + 1
}</programlisting>
</chapter>
<chapter xml:id="_mapas">
<title>Mapas</title>
<simpara>Los mapas, también conocidos como "diccionarios" permiten almacenar distintas variables
que pueden ser accedidas mediante un identificador.</simpara>
<programlisting language="js" linenumbering="numbered">var mivar = true

var mapa = {
  "1": 1,
  "dos": 2,
  "mivar"; mivar
}</programlisting>
<simpara>A diferencia de otros lenguajes, no se puede acceder directamente a las distintas variables
con el identificador.</simpara>
<programlisting language="js" linenumbering="numbered">mapa.mivar // error
mapa["mivar"] // ok</programlisting>
</chapter>
<chapter xml:id="_clases">
<title><link xl:href="https://wren.io/classes.html">Clases</link></title>
<simpara>Las clases son una estructura de datos bastante flexible. Permiten definir la información y el comportamiento de cualquier unidad que desees modelar en los programas.</simpara>
<section xml:id="_terminología_de_orientación_a_objetos">
<title>Terminología de Orientación a Objetos</title>
<simpara>Las clases son parte de un paradígma llamado "Programación Orientada a Objetos" (Object-oriented programming) (<emphasis>P.O.O</emphasis> u <emphasis>O.O.P</emphasis>). La cual se focaliza en construir bloques reusables de código llamados <emphasis>Clases</emphasis>. Cuando se necesita utilizar una clase se debe crear un objeto (o instancia), por eso el término de orientación a objetos. Para entender mejor, se debe conocer la terminología común.</simpara>
<itemizedlist>
<listitem>
<simpara>Una clase es un bloque de código que define atributos (propiedades) y comportamientos necesarios (métodos) para modelar adecuadamente un elemento del programa. Se puede modelar algo del mundo real como una pelota o una guitarra o algo de un mundo virtual como un personaje de un videojuego y sus leyes físicas.</simpara>
</listitem>
<listitem>
<simpara>Un atributo (o propiedad) es una pieza de información. Es técnicamente una variable que es parte de una clase.</simpara>
</listitem>
<listitem>
<simpara>Un comportamiento es una acción definida dentro de una clase. Son comunmente conocidos como métodos, los cuales son las funciones definidoas para la clase.</simpara>
</listitem>
<listitem>
<simpara>Un objeto es una instancia específica de una clase. Tiene valores definidos para los atributos (variables) de la clase. Se pueden crear tantos objetos de una misma clase, como sea necesario.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_el_operador_is">
<title>El operador <literal>is</literal></title>
<simpara>El operador <literal>is</literal> tiene dos funciones. La primera es permitir la herencia simple entre clases
y la segunda permite comparar si un objeto pertenece a una metaclase específica.</simpara>
<section xml:id="_ejemplo_juego_de_piedra_papel_tijera">
<title>Ejemplo: Juego de Piedra - Papel - Tijera</title>
<simpara>El siguiente juego de Piedra, Papel o Tijeras es implementado mediante
una herencia simple. Se utiliza el <link xl:href="https://lostechies.com/jimmybogard/2010/03/30/strengthening-your-domain-the-double-dispatch-pattern/">patrón de diseño de double dispatch</link>, para simplificar su lógica.</simpara>
<programlisting language="js" linenumbering="numbered">// Piedra, Papel o Tijeras
// Usando el Patron de Double Dispatch
class Elemento {
  pierdeCon(elemento) {}
  leGanaAPiedra(){}
  leGanaAPapel(){}
  leGanaATijera(){}
}

class Piedra is Elemento {
  construct crear() {}

  pierdeCon(elemento) {
    return elemento.leGanaAPiedra()
  }

  leGanaAPiedra() {
    return false
  }

  leGanaAPapel() {
    return false
  }

  leGanaATijera() {
    return true
  }
}

class Papel is Elemento {
  construct crear() {}

  pierdeCon(elemento) {
    return elemento.leGanaAPapel()
  }

  leGanaAPiedra() {
    return true
  }

  leGanaAPapel() {
    return false
  }

  leGanaATijera() {
    return false
  }
}

class Tijera is Elemento {
  construct crear() {}

  pierdeCon(elemento) {
    return elemento.leGanaATijera()
  }

  leGanaAPiedra() {
    return false
  }

  leGanaAPapel() {
    return true
  }

  leGanaATijera() {
    return false
  }
}

var piedra = Piedra.crear()
var papel = Papel.crear()
var tijera = Tijera.crear()

System.print(piedra.pierdeCon(papel))  // true (verdadero)
System.print(tijera.pierdeCon(piedra)) // true (verdadero)
System.print(piedra.pierdeCon(tijera)) // false (falso)
System.print(papel.pierdeCon(tijera))  // true (verdadero)
System.print(papel.pierdeCon(piedra))  // false (falso)</programlisting>
</section>
<section xml:id="_ejemplo_de_comparación">
<title>Ejemplo de comparación</title>
<simpara>Ahora utilizando las clases de Piedra, Papel o Tijeras vamos a comparar los elementos
utilizando el operador <literal>is</literal>.</simpara>
<programlisting language="js" linenumbering="numbered">var piedra = Piedra.crear()

System.print(piedra is Piedra) // true (verdadero)
System.print(piedra == Piedra) // false (falso)

System.print(piedra is Tijera) // false (falso)
System.print(piedra == Tijera) // false (falso)

System.print(piedra is Elemento) // true (verdadero)
System.print(piedra == Elemento) // false (falso)

System.print(Piedra is Elemento) // false (falso)
System.print(Piedra == Elemento) // false (falso)

System.print(Piedra.supertype is Elemento) // false (falso)
System.print(Piedra.supertype == Elemento) // true (verdadero)</programlisting>
<simpara>Analizando los resultados verdaderos:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>(piedra is Piedra)</literal>: Verdadero puesto que el objeto <emphasis>piedra</emphasis> es una instancia de la clase <emphasis>Piedra</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><literal>(piedra is Elemento)</literal>: Verdadero puesto que el objeto <emphasis>piedra</emphasis> es una instancia de la clase <emphasis>Piedra</emphasis> y ésta a su vez hereda de <emphasis>Elemento</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><literal>(Piedra.supertype == Elemento)</literal>: Verdadero puesto que el super tipo de <emphasis>Piedra</emphasis> es la misma referencia a la clase <emphasis>Elemento</emphasis>.</simpara>
</listitem>
</itemizedlist>
<simpara>Analizando los resultados falsos:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>(piedra == Piedra)</literal>: Falso puesto que el objeto <emphasis>piedra</emphasis> no tiene la misma referencia que la clase <emphasis>Piedra</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><literal>(piedra is Tijera)</literal>: Falso puesto que el objeto <emphasis>piedra</emphasis> no es una instancia de la clase <emphasis>Tijera</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><literal>(piedra == Tijera)</literal>: Falso puesto que el objeto <emphasis>piedra</emphasis> no tiene la misma referencia que la clase <emphasis>Tijera</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><literal>(piedra == Elemento)</literal>: Falso puesto que el objeto <emphasis>piedra</emphasis> no tiene la misma referencia que la clase <emphasis>Elemento</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><literal>(Piedra is Elemento)</literal>: Falso puesto que la clase <emphasis>Piedra</emphasis> no es una instancia de la clase <emphasis>Elemento</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><literal>(Piedra == Elemento)</literal>: Falso puesto que la clase <emphasis>Piedra</emphasis> no es una referencia a la clase <emphasis>Elemento</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><literal>(Piedra.supertype is Elemento)</literal>: Falso pues que el super tipo de <emphasis>Piedra</emphasis> no hereda de <emphasis>Elemento</emphasis> (ya que el super tipo de <emphasis>Piedra</emphasis> es <emphasis>Elemento</emphasis>).</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_ejemplo_sobrecarga_del_operador">
<title>Ejemplo: Sobrecarga del operador</title>
<simpara>Podemos sobrecargar el operador <literal>is</literal> en nuestras clases y "ocultar" su real naturaleza.
Normalmente podría ser usado para reemplazar las clases básicas (<emphasis>String</emphasis>, <emphasis>Num</emphasis>, <emphasis>Bool</emphasis>, <emphasis>Fn</emphasis>, <emphasis>Fiber</emphasis>, <emphasis>Map</emphasis>, <emphasis>List</emphasis>, <emphasis>Null</emphasis>, entre otras)
y permitir su extensión. Recordemos que en <emphasis>Wren</emphasis> no se puede heredar desde estas clases debido al problema de <link xl:href="https://es.wikipedia.org/wiki/Reentrancia_(inform%C3%A1tica)"><emphasis>Reentrancia</emphasis></link> (<emphasis>Wren</emphasis> no tiene esta capacidad).</simpara>
<simpara>Usarlo de esta forma no es común y solo se ha puesto a modo de ejemplo.</simpara>
<programlisting language="js" linenumbering="numbered">class Original {}

class Extendida {
  construct nueva() {}

  is(otra) {otra == Original}

  type {Original}
  static supertype {Original}
}

var instancia = Extendida.nueva()

System.print(instancia is Original) // true (verdadero)
System.print(instancia is Extendida) // false (falso)
System.print(instancia.type) // Original
System.print(Extendida.supertype) // Original</programlisting>
</section>
</section>
<section xml:id="_atributos">
<title><link xl:href="https://wren.io/classes.html#attributes">Atributos</link></title>
<simpara>Las clases en <emphasis>Wren</emphasis> pueden ser adornadas con atributos especiales. Estos permiten añadir
información para dar contexto o almacenar datos que pueden ser de utilidad para herramientas
de programación y otras utilidades.</simpara>
<simpara>Solamente pueden estar dentro de una declaración de clase o de método.</simpara>
<programlisting language="js" linenumbering="numbered">#atributo = "valor"
class MiClase {
  #atributo = "valor"
  metodo {true}
}</programlisting>
<simpara>Los valores pueden ser <emphasis>String</emphasis>, <emphasis>Num</emphasis>, <emphasis>Bool</emphasis> o el tipo especial <emphasis>group</emphasis>.
que permite agrupar distintos atributos en un marco en común.</simpara>
<programlisting language="js" linenumbering="numbered">#!cantidad = 10
#grupo(
  nombre = "Camilo"
)
class MiClase {
}</programlisting>
</section>
</chapter>
<chapter xml:id="_wren_console">
<title><link xl:href="https://github.com/joshgoebel/wren-console">Wren Console</link></title>
<simpara><emphasis>Wren Console</emphasis> es una pequeña y simple herramienta para ejecutar programas en <emphasis>Wren</emphasis>. Está respaldado por <emphasis>libuv</emphasis> (para IO).
Está basada en el projecto oficial de <emphasis>Wren CLI</emphasis>, aunque todavía es un trabajo en progreso.</simpara>
<programlisting language="js" linenumbering="numbered">#!/usr/bin/env wrenc

import "io" for Stdin

System.print("Ingresa tu nombre:")

var nombre = Stdin.readLine().trim()

System.print("Hola" + (nombre.isEmpty ? "Mundo" : nombre).toString + "!")
````



## Proyectos de ejemplo en Wren

Una colección de código fuente _Wren_ con juegos y aplicaciones simples.
Se recomienda utilizar un editor de código como https://vscodium.com/[VS Codium]
para escribir los ejemplos.

Cada ejemplo puede ser categorizado en los siguientes niveles:

.Niveles
|===
|Nivel|Descripción
|Novato| Utiliza operaciones simples como suma, resta, multiplicación, división, _System.print()_ y estructuras de control.
|Intermedio| Utiliza funciones, diccionarios y clases simples.
|Avanzado| Utiliza clases, herencia y algoritmos avanzados.
|===

### Terminal

Aplicaciones que no necesitan interfaz gráfica para funcionar, solamente necesitando _Wren CLI_ y la entrada/salida estándar.

Basados principalmente en los códigos diponibles en https://github.com/asweigart/PythonStdioGames[Python Stdio Games] y https://github.com/asweigart/inventwithpython3rded[Invent With Python].

#### ¿Cómo ejecutarlos?

Primero se necesita el https://github.com/wren-lang/wren-cli/releases/latest[intérprete de Wren].

Para mayor documentación sobre la consola y el lenguaje _Wren_ se puede visitar http://wren.io/cli

#### Adivina el Número

Basado en http://inventwithpython.com/es/4.html[Adivina del Número].

En el juego _"Adivina el Número"_. La computadora pensará un número aleatorio entre 1 y 20, y te pedirá que intentes adivinarlo. La computadora te dirá si cada intento es muy alto o muy bajo. Tú ganas si adivinas el número en seis intentos o menos.

Este es un buen juego para codificar ya que usa números aleatorios y bucles, y recibe entradas del usuario en un programa corto. Aprenderás cómo convertir valores a diferentes tipos de datos, y por qué es necesario hacer esto. Dado que este programa es un juego, nos referiremos al usuario como el jugador. Pero llamarlo “usuario” también sería correcto.

.Nivel
Novato

##### Ejemplo de Ejecución

`$ ./wren adivina/adivina.wren`

```sh

¡Hola! ¿Cómo te llamas?

Alberto

Bueno, Alberto, estoy pensando en un número entre 1 y 20.

Intenta adivinar 1/6.

10

Tu estimación es muy alta.

Intenta adivinar 2/6.

2

Tu estimación es muy baja.

Intenta adivinar 3/6.

4

¡Buen trabajo, Alberto! ¡Has adivinado mi número en 3 intentos!</programlisting>
<section xml:id="_código_fuente">
<title>Código fuente</title>
<programlisting language="js" linenumbering="numbered">// nombre: adivina.wren
// autor: Camilo Castro &lt;camilo@ninjas.cl&gt;
// original: https://github.com/asweigart/inventwithpython3rded/blob/master/translations/es/src/adivinaElN%C3%BAmero.py
// ejecutar: wren adivina/adivina.wren

import "random" for Random
import "io" for Stdin

var random = Random.new()

var intentos = 0
var maxIntentos = 6

System.print("¡Hola!, ¿Cómo te llamas?")

var nombre = Stdin.readLine()
System.print("Bueno, %(nombre), estoy pensando en un número entre 1 y 20.")

// Un número aleatorio entre 1 y 20.
// se necesita usar 21 debido a que el generador
// no incluye el último número.
var numero = random.int(1, 21)
var estimacion = -1

while (intentos &lt; maxIntentos) {
    intentos = intentos + 1
    System.print("Intenta adivinar %(intentos)/%(maxIntentos)")
    
    estimacion = Num.fromString(Stdin.readLine())

    if (estimacion is Null) {
        System.print("Solo admito números")
    } else if (estimacion &lt; numero) {
        System.print("Tu estimación es muy baja")
    } else if (estimacion &gt; numero) {
        System.print("Tu estimación es muy alta")
    } else {
        break
    }
}

if (estimacion == numero) {
    System.print("¡Buen trabajo, %(nombre)! ¡Haz adivinado mi número en %(intentos) intentos!.")
}

if (estimacion != numero) {
    System.print("Pues no. El número que estaba pensando era %(numero)")
}</programlisting>
</section>
<section xml:id="_reino_de_dragones">
<title>Reino de Dragones</title>
<simpara>Basado en <link xl:href="http://inventwithpython.com/es/6.html">Reino de Dragones</link>.</simpara>
<simpara>El juego se llama <emphasis>"Reino de Dragones"</emphasis>, y permite al jugador elegir entre dos cuevas, en una de las cuales encontrará un tesoro y en la otra su perdición.</simpara>
<formalpara>
<title>Nivel</title>
<para>Novato</para>
</formalpara>
<section xml:id="_cómo_jugar_a_reino_de_dragones">
<title>¿Cómo Jugar a Reino de Dragones?</title>
<simpara>En este juego, el jugador está en una tierra llena de dragones. Todos los dragones viven en cuevas junto a sus grandes montones de tesoros encontrados. Algunos dragones son amigables, y compartirán sus tesoros contigo. Otros son codiciosos y hambrientos, y se comerán a cualquiera que entre a su cueva. El jugador se encuentra frente a dos cuevas, una con un dragón amigable y la otra con un dragón hambriento. El jugador tiene que elegir entre las dos.</simpara>
</section>
<section xml:id="_ejemplo_de_ejecución">
<title>Ejemplo de Ejecución</title>
<simpara><literal>$ ./wren dragon/dragon.wren</literal></simpara>
<programlisting language="sh" linenumbering="numbered">Estás en una tierra llena de dragones. Frente a tí
hay dos cuevas. En una de ellas, el dragón es generoso y amigable y compartirá su tesoro contigo. El otro dragón
es codicioso y está hambriento, y te devorará inmediatamente.

¿A qué cueva quieres entrar? (1 ó 2)
1

Te aproximas a la cueva...
Es oscura y espeluznante...
¡Un gran dragon aparece súbitamente frente a tí! Abre sus fauces y...

¡Te engulle de un bocado!

¿Quieres jugar de nuevo? (sí or no)

no</programlisting>
</section>
<section xml:id="_código_fuente_2">
<title>Código fuente</title>
<programlisting language="js" linenumbering="numbered">// nombre: dragon.wren
// autor: Camilo Castro &lt;camilo@ninjas.cl&gt;
// original: https://github.com/asweigart/inventwithpython3rded/blob/master/translations/es/src/drag%C3%B3n.py
// ejecutar: wren dragon/dragon.wren

import "random" for Random
import "timer" for Timer
import "io" for Stdin

var random = Random.new()

var mostrarIntroduccion = Fn.new {
  System.print("Estás en una tierra llena de dragones. Frente a tí")
  System.print("hay dos cuevas. En una de ellas, el dragón es generoso y")
  System.print("amigable y compartirá su tesoro contigo. El otro dragón")
  System.print("es codicioso y está hambriento, y te devorará inmediatamente.")
  System.print()
  }

  var elegirCueva = Fn.new {
  var cueva = null
  var primerDragon = "1"
  var segundoDragon = "2"

  while (cueva != primerDragon &amp;&amp; cueva != segundoDragon) {
    System.print("¿A qué cueva quieres entrar? (1 ó 2)")
    cueva = Stdin.readLine()
  }
  return cueva
}

var explorarCueva = Fn.new { |cueva|
    // existen 1000 millisegundos en un segundo
    // por lo que para obtener 2 segundos
    // debemos multiplicar 2 * 1000
    var dosSegundos = 2 * 1000

    System.print("Te aproximas a la cueva...")
    Timer.sleep(dosSegundos)
    
    System.print("Es oscura y espeluznante...")
    Timer.sleep(dosSegundos)
    
    System.print("¡Un gran dragon aparece súbitamente frente a tí! Abre sus fauces y...")
    System.print()
    Timer.sleep(dosSegundos)

    // Un número aleatorio entre 1 y 2.
    // se necesita usar 3 debido a que el generador
    // no incluye el último número
    var cuevaAmigable = random.int(1, 3).toString

    if (cueva == cuevaAmigable) {
      System.print("¡Te regala su tesoro!")
    } else {
      System.print("¡Te engulle de un bocado!")
    }

    System.print()
}

var jugarDeNuevo = "sí"
while (jugarDeNuevo == "sí" || jugarDeNuevo == "si" || jugarDeNuevo == "s") {
  mostrarIntroduccion.call()
  var cueva = elegirCueva.call()
  explorarCueva.call(cueva)

  System.print("¿Quieres jugar de nuevo? (sí o no)")
  jugarDeNuevo = Stdin.readLine()
}

System.print("¡Eso fue divertido, nos vemos luego!")</programlisting>
</section>
</section>
<section xml:id="_diamantes">
<title>Diamantes</title>
<simpara>Esta es una simple aplicación creativa que muestra
diamantes de distintos tamaños.
Basado en <link xl:href="https://github.com/asweigart/PythonStdioGames/blob/main/src/gamesbyexample/diamonds.py">Diamonds</link>.</simpara>
<formalpara>
<title>Nivel</title>
<para>Novato</para>
</formalpara>
<section xml:id="_ejemplo_de_ejecución_2">
<title>Ejemplo de Ejecución</title>
<simpara><literal>./wren diamantes/diamantes.wren</literal></simpara>
<programlisting language="sh" linenumbering="numbered">/\
\/

/\
\/

 /\
/  \
\  /
 \/
...</programlisting>
</section>
<section xml:id="_código_fuente_3">
<title>Código fuente</title>
<programlisting language="js" linenumbering="numbered">/*
Diamantes, por Al Sweigart &lt;al@inventwithpython.com&gt;
https://github.com/asweigart/PythonStdioGames/blob/main/src/gamesbyexample/diamonds.py
Dibuja diamantes de varios tamaños.
Adaptado a Wren por Camilo Castro &lt;camilo@ninjas.cl&gt;
https://github.com/NinjasCL/wren-libro/blob/main/juegos/diamantes/diamantes.wren
- Tags: tiny, beginner, artistic, pequeño, novato, artistico
- Version: 1.0.0
*/

var mostrarDiamanteLineal = Fn.new { |dimension|
  // Mostrar la parte superior del diamante
  for (i in 0...dimension) {
    // Espacio izquierdo
    System.write(" " * (dimension - i - 1))
    // Parte izquierda del diamante
    System.write("/")
    // Espacio interior del diamante
    System.write(" " * (i * 2))
    // Parte derecha del diamante
    System.print("\\")
  }

  // Mostrar la parte inferior del diamante
  for (i in 0...dimension) {
    // Espacio izquierdo
    System.write(" " * i)
    // Lado izquierdo
    System.write("\\")
    // Espacio interior
    System.write(" " * ((dimension - i - 1) * 2))
    // Lado derecho
    System.print("/")
  }
}

var mostrarDiamanteRelleno = Fn.new { |dimension|
  // Mostrar la cara superior del diamante
  for (i in 0...dimension) {
    // Espaciado izquierdo
    System.write(" " * (dimension - i - 1))
    // Lado izquierdo
    System.write("/" * (i + 1))
    // Lado derecho
    System.print("\\" * (i + 1))
  }

  // Mostrar la cara inferior del diamante
  for (i in 0...dimension) {
    // Espaciado izquierdo
    System.write(" " * i)
    // Lado izquierdo
    System.write("\\" * (dimension - i))
    // Lado derecho
    System.print("/" * (dimension - i))
  }
}

// Muestra 5 diamantes de tamaño 0 al 5:
for(dimension in 0..5) {
  mostrarDiamanteLineal.call(dimension)
  System.print()
  mostrarDiamanteRelleno.call(dimension)
  System.print()
}</programlisting>
</section>
</section>
<section xml:id="_carrera_de_caracoles">
<title>Carrera de Caracoles</title>
<simpara>Una alucinante carrera entre 2 a 8 caracoles.
Basado en <link xl:href="https://github.com/asweigart/PythonStdioGames/blob/main/src/gamesbyexample/snailrace.py">SnailRace</link>.</simpara>
<formalpara>
<title>Nivel</title>
<para>Intermedio</para>
</formalpara>
<section xml:id="_ejemplo_de_ejecución_3">
<title>Ejemplo de Ejecución</title>
<simpara><literal>$ ./wren caracoles/caracoles.wren</literal></simpara>
<screen linenumbering="numbered">La gran carrera de caracoles

    @v &lt;-- caracol


¿Cuántos caracoles correrán? Min:2 Max:8
2
Ingresa el nombre del caracol #1:
Ana
Ingresa el nombre del caracol #2:
Berto

INICIO                                  META
|                                       |
                                     Ana
.....................................@v
                                       Berto
.......................................@v
¡Ha ganado Berto!</screen>
</section>
<section xml:id="_código_fuente_4">
<title>Código fuente</title>
<programlisting language="js" linenumbering="numbered">/*
Snail Race, por Al Sweigart &lt;al@inventwithpython.com&gt;
https://github.com/asweigart/PythonStdioGames/blob/main/src/gamesbyexample/snailrace.py
Una carrera de caracoles, ¡alucinante!.
Adaptado a Wren por Camilo Castro &lt;camilo@ninjas.cl&gt;
https://github.com/NinjasCL/wren-libro/blob/main/juegos/caracoles/caracoles.wren
- Tags: short, beginner, artistic, corto, novato, artistico
- Version: 1.0.0
*/
import "random" for Random
import "timer" for Timer
import "io" for Stdin

var random = Random.new()

class Constantes {
  static minCaracoles { 2 }
  static maxCaracoles { 8 }
  static maxLargoNombre { 20 }
  static meta { 40 }
}


System.print("
La gran carrera de caracoles

    @v &lt;-- caracol

")

var cantidad = null

while (true) {
  System.print("¿Cuántos caracoles correrán? Min:%(Constantes.minCaracoles) Max:%(Constantes.maxCaracoles)")
  cantidad = Num.fromString(Stdin.readLine())
  if (cantidad &amp;&amp; cantidad &gt;= Constantes.minCaracoles &amp;&amp; cantidad &lt;= Constantes.maxCaracoles) {
    break
  }
  System.print("Ingresar un número entre %(Constantes.minCaracoles) y %(Constantes.maxCaracoles)")
}

var nombres = []

for (i in 1..cantidad) {
  var nombre = ""
  while (true) {
    
    System.print("Ingresa el nombre del caracol #%(i):")
    nombre = Stdin.readLine()

    // Reducimos el nombre a su largo máximo
    nombre = nombre.take(Constantes.maxLargoNombre).join()
    
    if (nombre.count == 0) {
      System.print("Por favor ingresa un nombre.")
    } else if (nombres.contains(nombre)) {
      System.print("Nombre ya existe")
    } else {
      break
    }
  }
  nombres.add(nombre)
}

System.print("\n" * 40)
System.print("INICIO" + " " * (Constantes.meta - "INICIO".count) + "META")
System.print("|" + " " * (Constantes.meta - "|".count) + "|")

var caracoles = {}

for (nombre in nombres) {
  System.print(nombre)
  System.print("@v")
  caracoles[nombre] = 0
}

// 1.5 segundos
Timer.sleep(15 * 100)

while (true) {

  for (i in 0..(random.int(1, cantidad + 1))) {
    var nombre = random.sample(nombres)
    caracoles[nombre] = caracoles[nombre] + 1

    if (caracoles[nombre] &gt;= Constantes.meta) {
      System.print("¡Ha ganado %(nombre)!")
      // Terminar el proceso del juego
      Fiber.yield()
    }
  }

  // 0.5 segundos
  Timer.sleep(500)

  System.print("\n" * 40)
  System.print("INICIO" + " " * (Constantes.meta - "INICIO".count) + "META")
  System.print("|" + " " * (Constantes.meta - "|".count) + "|")

  for (nombre in nombres) {
    var espacios = caracoles[nombre]
    System.print(" " * espacios + nombre)
    System.print("." * espacios + "@v")
  }
}</programlisting>
</section>
</section>
<section xml:id="_cañon">
<title>Cañon</title>
<simpara>Este juego simula el disparo de un cañón hacia un objetivo.
Código levemente basado en <xref linkend="alfonseca"/>.</simpara>
<formalpara>
<title>Nivel</title>
<para>Intermedio</para>
</formalpara>
<section xml:id="_cómo_jugar">
<title>¿Cómo Jugar?</title>
<simpara>El jugador debe ingresar el ángulo para cada tiro del cañón.</simpara>
</section>
<section xml:id="_ejemplo_de_ejecución_4">
<title>Ejemplo de Ejecución</title>
<screen linenumbering="numbered">Quedan 1 objetivos
El cañón puede disparar hasta 34595 metros
El objetivo está a 6788 metros
La fórmula de la distancia es: alcance * sin(2 * ángulo * π / 180)

Ingrese el ángulo para disparar
5
Distancia Alcanzada: 10690 Distancia Objetivo: 6788

El tiro se pasó en 3902 metros.
¡Prueba otra vez!, quedan 4 tiros

Ingrese el ángulo para disparar
3.1
Distancia Alcanzada: 6695 Distancia Objetivo: 6788

!!BooOOOM!!
¡Felicidades!, haz destruido al objetivo en 2 intentos.</screen>
</section>
<section xml:id="_código_fuente_5">
<title>Código fuente</title>
<programlisting language="js" linenumbering="numbered">/**
Juego que simula el disparo de un cañón hacia un objetivo.
El jugador debe ingresar el ángulo para cada tiro del cañón.
Código levemente basado en la obra "Cómo construir juegos de aventura"
de Manuel Afonseca. ISBN 84-7688-019-7
- Author: Camilo Castro &lt;camilo@ninjas.cl&gt;
- Version: 1.0.0
*/

import "random" for Random
import "io" for Stdin

var random = Random.new()

var alcance = 0

var objetivos = 3
var oportunidades = 5

// Ángulos deben estar en grados
// mínimo 0.5, máximo 89.5
var anguloElevacion = 0.5
var anguloMinimo = 0.5
var anguloMaximo = 89.5

// Sentinela para saber si el objetivo fue destruido
var destruido = false

// Para saber cuantos tiros fueron
// necesarios para destruir al objetivo
var tiros = 0

// Distancia mínima requerida para considerar
// al objetivo como destruido
// Si el proyectil llega a los 100 metros del objetivo
// se considera destruido
// (en metros).
var distanciaMinima = 100

// Distancia alcanzada por el tiro (en metros)
var distanciaAlcanzada = 0

// Distancia final
// distanciaAlcanzada - distanciaObjetivo
var distanciaFinal = 0

// Distancia al azar del objetivo
// Debe ser igual o menor al alcance del cañón
// entre 100 hasta el alcance del cañón.
var distanciaObjetivo = 0

var jugar = true
while (jugar) {

  System.print("Quedan %(objetivos) objetivos")

  // Valores iniciales por cada objetivo
  oportunidades = 5
  destruido = false
  anguloElevacion = 0
  distanciaFinal = 0
  tiros = 1
  
  // Un número aleatorio entre 10K y 50K
  // Usamos notación científica para simplificar el número
  alcance = random.int(10e3, 50e3 + 1)

  distanciaObjetivo = random.int(distanciaMinima, alcance + 1)

  System.print("El cañón puede disparar hasta %(alcance) metros")
  System.print("El objetivo está a %(distanciaObjetivo) metros")
  System.print("La fórmula de la distancia es: alcance * sin(ángulo * 2 * π / 180)")

  while (oportunidades &gt; 0) {

    while (anguloElevacion &lt; anguloMinimo || anguloElevacion &gt; anguloMaximo) {
      System.print()
      System.print("Ingrese el ángulo para disparar")
      anguloElevacion = Num.fromString(Stdin.readLine())

      if (!anguloElevacion) {
        System.print("Debe ingresar un ángulo.")
        anguloElevacion = 0
      } else if (anguloElevacion &gt; anguloMaximo) {
        System.print("El ángulo debe ser menor a %(anguloMaximo)")
      } else if (anguloElevacion &lt; anguloMinimo) {
        System.print("El ángulo debe ser mayor a %(anguloMinimo)")
      }
    }

    // Calculamos la distancia que el tiro llega con el ángulo ingresado.
    // La fórmula matemática (ángulo * 2π/180) convierte los grados del ángulo de
    // a radianes. Considerando 360º.
    // Luego se multiplica el alcance por el seno de los radianes obtenidos
    // para obtener la distancia alcanzada.
    // Finalmente se redondea el resultado para obtener un número entero.
    // Ver: http://math2.org/math/trig/es-tables.htm
    // Ver: https://es.khanacademy.org/science/physics/two-dimensional-motion/two-dimensional-projectile-mot/v/projectile-at-an-angle

    distanciaAlcanzada = (alcance * (anguloElevacion * ( 2 * Num.pi / 180)).sin).round
    distanciaFinal = (distanciaAlcanzada - distanciaObjetivo).abs
    System.print("Distancia Alcanzada: %(distanciaAlcanzada.abs) Distancia Objetivo: %(distanciaObjetivo) Diferencia: %(distanciaFinal)")

    destruido = (distanciaMinima &gt;= distanciaFinal)

    if (destruido) {
      objetivos = objetivos - 1
      jugar = (objetivos &gt; 0)
      System.print()
      System.print("!!BooOOOM!!")
      System.print("¡Felicidades!, haz destruido al objetivo en %(tiros) intentos.")
      System.print()
      break
    }

    // Aumentamos el contador de tiros
    tiros = tiros + 1

    // Y reiniciamos el angulo de elevación
    // para volver a solicitarlo
    anguloElevacion = 0
    oportunidades = oportunidades - 1
    System.print()

    if (distanciaAlcanzada &gt; distanciaObjetivo) {
      System.print("El tiro se pasó en %(distanciaFinal) metros.")
    } else {
      System.print("El tiro quedó corto por %(distanciaFinal) metros.")
    }
    
    jugar = (oportunidades &gt; 0)
    if (jugar) {
      System.print("¡Prueba otra vez!, quedan %(oportunidades) tiros")
    } else {
      System.print("Juego terminado. ¡Haz perdido todas tus balas!")
    }
  }
}</programlisting>
</section>
</section>
<section xml:id="_gráficos">
<title>Gráficos</title>
<simpara>Aplicaciones que necesitan <link xl:href="http://tic80.com/"><emphasis>TIC 80</emphasis></link> u <link xl:href="https://domeengine.com/"><emphasis>Dome Engine</emphasis></link> para ser ejecutados.</simpara>
<section xml:id="_breakout">
<title><link xl:href="https://github.com/NinjasCL/breakout">Breakout</link></title>
<simpara>Un clon simple del famoso juego de <emphasis>Breakout</emphasis>.
Debes eliminar todos los bloques dentro de la pantalla utilizando
una raqueta y una pelota. El juego termina si la raqueta falla
en golpear la pelota.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/NinjasCL/breakout/main/breakout.gif"/>
</imageobject>
<textobject><phrase>Breakout</phrase></textobject>
</inlinemediaobject></simpara>
<formalpara>
<title>Nivel</title>
<para>Avanzado</para>
</formalpara>
<section xml:id="_código_fuente_6">
<title>Código fuente</title>
<programlisting language="js" linenumbering="numbered">// title:  Clone de breakout para TIC-80
// author: Camilo Castro
// desc:   Un simple clon de breakout en Wren
// script: wren
// based on: https://github.com/digitsensitive/tic-80-tutorials/tree/master/tutorials/breakout

import "random" for Random

var Seed = Random.new()
var T = TIC

class ScreenWidth {
    static min {0}
    static max {240}
}

class ScreenHeight {
    static min {0}
    static max {136}
}
    
class Screen {
    static height {ScreenHeight}
    static width {ScreenWidth}
}

class Input {
    static left {T.btn(2)}
    static right {T.btn(3)}
    static x {T.btn(5)}
}

class Color {
    static black {0}
    static white {12}
    static orange {3}
    static greyl {13}
    static greyd {15}
}

class Collisions {
   // Implements
  // https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
  static collide(hitbox, hitbox2) {
    return (hitbox.x &lt; hitbox2.x + hitbox2.width &amp;&amp;
            hitbox.x + hitbox.width &gt; hitbox2.x &amp;&amp;
            hitbox.y &lt; hitbox2.y + hitbox2.height &amp;&amp;
            hitbox.y + hitbox.height &gt; hitbox2.y)
  }
}

class PlayerSpeed {
    x {_x}
    x = (value) {
        _x = value
    }
    
    max {_max}
    max = (value) {
        _max = value
    }
    
    construct new() {
        _x = 0
        _max = 4
    }
}

class Player {
    x {_x}
    y {_y}
    width {_width}
    height {_height}
    color {_color}
    speed {_speed}

    state {_state}

    construct new(state) {
        _state = state
        _width = 24
        _height = 4
        _y = 120
        _color = Color.orange
        reset()
    }

    reset() {
        _x = (Screen.width.max/2) - _width/2
        _speed = PlayerSpeed.new()
    }

    draw() {
        T.rect(x, y, width, height, color)
    }

    wall() {
        if (x &lt; Screen.width.min) {
            _x = Screen.width.min
        } else if(x + width &gt; Screen.width.max) {
            _x = Screen.width.max - width
        }
    }

    collisions() {
        wall()
    }

    update() {
        _x = x + speed.x
        if (speed.x != 0) {
            if (speed.x &gt; 0) {
              speed.x = speed.x - 1
            } else {
              speed.x = speed.x + 1
            }
        }
    }

    input() {
        if (Input.left) {
                if (speed.x &gt; -speed.max) {
                    speed.x = speed.x - 2
                } else {
                    speed.x = -speed.max
                }
            }
            
            if (Input.right) {
                if (speed.x &lt; speed.max) {
                        speed.x = speed.x + 2
                    } else {
                        speed.x = speed.max
                    }
            }
    }
}

class BallSpeed {
    x {_x}
    x = (value) {
        _x = value
    }
    
    y {_y}
    y = (value) {
        _y = value
    }
    
    max {_max}
    
    construct new() {
        _x = 0
        _y = 0
        _max = 1.5
    }
}

class Ball {
    x {_x}
    y {_y}
    width {_width}
    height {_height}
    color {_color}
    deactive {_deactive}
    speed {_speed}
    
    player {_player}
    player = (value) {
        _player = value
    }
    
    state {_state}
    
    construct new(player, state) {
        _width = 3
        _height = 3
        _color = Color.greyl
        _player = player
        _state = state
        reset()
    }
    
    position() {
        _x = player.x + (player.width / 2) - 1.5
        _y = player.y - 5
    }
    
    reset() {
        position()
        _deactive = true
        _speed = BallSpeed.new()
    }
    
    input() {
        if (deactive) {
                position()
                if (Input.x) {
                    speed.x = (Seed.float(0, 10).floor * 2) - 1
                        speed.y = speed.y - 1.5
                        _deactive = false
                }
            }
    }
    
    wall() {
        // top
        if (y &lt; 0) {
            speed.y = -speed.y
            
        // left
        } else if (x &lt; 0) {
            speed.x = -speed.x
        
        // right
        } else if (x &gt; 240 - width) {
            speed.x = -speed.x
        }
    }
    
    ground() {
        if (y &gt; 136 - width) {
                reset()
                state.lifeDown()
        }
    }
    
    paddle() {
        if (Collisions.collide(this, player)) {
            speed.y = -speed.y
            speed.x = speed.x + 0.3 * player.speed.x
        } 
    }
    
    brick(brick) {

        // collide left or right side
        if (brick.y &lt; y &amp;&amp;
            y &lt; brick.y + brick.height &amp;&amp;
            (x &lt; brick.x || brick.x + brick.width &lt; x)) {
                speed.x = -speed.x
            }
        // collide top or bottom
        if (y &lt; brick.y ||
        (y &gt; brick.y &amp;&amp; brick.x &lt; x &amp;&amp;
        x &lt; brick.x + brick.width)) {
            speed.y = -speed.y
        }
    }

    collisions() {
        wall()
        ground()
        paddle() 
    }
    
    update() {
        _x = x + speed.x
        _y = y + speed.y
        
        if (speed.x &gt; speed.max) {
            speed.x = speed.max
        }
    }
    
    draw() {
        T.rect(x, y, width, height, color)
    }
}

class Brick {
    x {_x}
    y {_y}
    width {_width}
    height {_height}
    color {_color}

    construct new(x, y, color) {
        _x = x
        _y = y
        _width = 10
        _height = 4
        _color = color
    }
    
    draw() {
        T.rect(x, y, width, height, color)
    }
}

class Board {
    width {19}
    height {12}

    ball {_ball}
    state {_state}

    bricks {
        if (!_bricks) {
            _blicks = []
        }

        return _bricks
    }
        
    construct new(ball, state) {
        _ball = ball
        _state = state
        reset()
    }

    reset() {
        _bricks = []
        for (i in 0..height) {
            for (j in 0..width) {
                var x = 10 + j * 11
                var y = 10 + i * 5
                var color = i + 1
                var brick = Brick.new(x, y, color)
                bricks.add(brick)
            }
        }
								ball.reset()
    }
        
    draw() {
        bricks.each {|brick|
            brick.draw()
        }
    }
    
    collisions() {
        var index = 0
        if (bricks.count &lt;= 0) {
            reset()
        }

        var note = "C-%(Seed.int(4,7))"

        bricks.each {|brick|
            if (Collisions.collide(ball, brick)) {
                T.sfx(0, note, 10)
                bricks.removeAt(index)
                ball.brick(brick)
                state.scoreUp()
            }
            index = index + 1
        }
    }
    
    update() {}
    input() {}
}

class Stage {
    objects {_objects}
    state {_state}
    
    construct new(state) {
        _objects = []
        _state = state
    }
    
    add(object) {
        objects.add(object)
    }
    
    input() {
        if (!state.isPlaying) return
        
        objects.each {|object|
            object.input()
        }
    }
    
    draw() {
        if (!state.isPlaying) return
        
        objects.each {|object|
            object.draw()
        }
    }
    
    update() {
    
        if (!state.isPlaying) return
        
        objects.each {|object|
            object.update()
        }
    }
    
    collisions() {
        if (!state.isPlaying) return 
        
        objects.each {|object|
            object.collisions()
        }
    }
}

class GUI {
    player {_player}
    state {_state}
    
    construct new(player, state) {
        _player = player
        _state = state
    }
    
    scores() {
       // shadow
        T.print("SCORE ", 5, 1, Color.greyd)
        T.print(state.score, 40, 1, Color.greyd)
        
        // forecolor
        T.print("SCORE ", 5, 0, Color.white)
        T.print(state.score, 40, 0, Color.white)
        
        // shadow
        T.print("LIVES ", 190, 1, Color.greyd)
        T.print(state.lives, 225, 1, Color.greyd)
        
        // forecolor
        T.print("LIVES ", 190, 0, Color.white)
        T.print(state.lives, 225, 0, Color.white)
    }
    
    gameover() {
      T.print("Game Over", (Screen.width.max/2) - 6 * 4.5, 136/2, Color.white) 
    }
    
    input() {
        if (!state.isPlaying &amp;&amp; Input.x) {
            state.start()
        }
    }
    
    draw() {
        if (state.isPlaying) {
            return scores()
        }
        gameover()
    }
}

class GameState {
    static game {__game}
    static game = (value) {
        __game = value
    }

    static isPlaying {__playing}
    
    static score {
        if (!__score) {
            __score = 0
        }
        
        return __score
    }
    
    static score = (value) {
        __score = value
    }
    
    static lives {
        if (!__lives || __lives &lt; 0) {
            __lives = 3
        }
        
        return __lives
    }
    
    static lives = (value) {
        if (value &lt; 0) {
            over()
        }
        __lives = value
    }
    
    static over() {
        reset()
        __playing = false
    }
    
    static start() {
        __playing = true
    }
    
    static lifeDown() {
        lives = lives - 1
    }
    
    static scoreUp() {
        score = score + 100
    }
    
    static reset() {
        score = 0
        lives = 3
        game.reset()
    }
}



class Game is TIC {
    player {_player }
    stage {_stage }
    gui {_gui }
    
    construct new() {
        reset()
    }

    reset() {
        GameState.start()
        GameState.game = this

        _player = Player.new(GameState)
        _ball = Ball.new(_player, GameState)
        
        _gui = GUI.new(_player, GameState)
        
        _board = Board.new(_ball, GameState)
            
        _stage = Stage.new(GameState)
        _stage.add(_player)
        _stage.add(_ball)
        _stage.add(_board)
    }
    
    TIC() {
        T.cls(0)
        input()
        update()
        collisions()
        draw()
    }
    
    input() {
        gui.input()
        stage.input()
    }
    
    update() {
        stage.update()
    }
    
    collisions() {
        stage.collisions()
    }
    
    draw() {
        stage.draw()
        gui.draw()
    }
}</programlisting>
</section>
</section>
<section xml:id="_snake">
<title><link xl:href="https://github.com/NinjasCL/snake">Snake</link></title>
<simpara>Un clon simple del famoso juego de la serpiente.
Si come se agranda su cola y el juego termina al momento de que la cabeza
toque una parte de su propio cuerpo.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/NinjasCL/snake/main/game.gif"/>
</imageobject>
<textobject><phrase>Snake</phrase></textobject>
</inlinemediaobject></simpara>
<formalpara>
<title>Nivel</title>
<para>Avanzado</para>
</formalpara>
<section xml:id="_código_fuente_7">
<title>Código fuente</title>
<programlisting language="js" linenumbering="numbered">// title:  Clone de Snake para TIC-80
// author: Camilo castro
// desc:   Un pequeño clon de Snake
// script: wren
// based on: https://github.com/nesbox/TIC-80/wiki/Snake-Clone-tutorial

import "random" for Random

var Rand = Random.new()
var T = TIC

class Input {
		static up {T.btn(0)}
		static down {T.btn(1)}
		static left {T.btn(2)}
		static right {T.btn(3)}
		static x {T.btn(5)}
}

class Color {
  static black {0}
		static white {12}
		static green {5}
		static blue {10}
		static orange {3}
		static greyd {15} 
}

class Screen {
  static width {240}
		static height {136}
}

class Position {
  x {
		if (!_x) {
			_x = 0
			}
			return _x
		}
		
		x = (value) {
		_x = value
		}
		
		y {
		if (!_y) {
			_y = 0
			}
			return _y
		}
		
		y = (value) {
		_y = value
		}
		
		construct new(x, y) {
			_x = x
			_y = y
		}
}

class GameState {
  static game {__game}
		static game = (value) {
			__game = value
		}
		
		static snake {__snake}
		static snake = (value) {
			__snake = value
		}
		
		static score {
			if (!__score) {
				__score = 0
			}
			return __score
		} 
		
		static scoreUp() {
			__score = score + 100
		}
		
  static frame {
		if (!__frame || __frame &gt; Num.largest - 1) {
					__frame = 0
				}
				return __frame
		}
		
		static frameUp() {
			__frame = frame + 1
		}
		
		static isTenthFrame {frame % 10 == 0}
		
		static isPlaying {
			if (__isPlaying is Null) {
				__isPlaying = true
			}
			return __isPlaying
		}
		
		static isPlaying = (value) {
			__isPlaying = value
		}
		
		static start() {
			isPlaying = true
		}
		
		static gameover() {
			reset()
				isPlaying = false
		}
		
		static reset() {
			__score = 0
			game.reset()
		} 
}

class Food is Position {
	snake {_snake}
	
	construct new (snake) {
			_snake = snake
			place()
	}
	
	random() {
		x = Rand.int(0, 29)
		y = Rand.int(0, 16)
	}
	
	place() {
		random()
		snake.body.each{|part|
			if (part.x == x &amp;&amp; part.y == y) {
					place()
			}
		}
	}
	
	draw() {
	  T.rect(x * 8, y * 8, 8, 8, Color.orange)
	}
	
	update() {}
	input() {}
	
	collisions() {
		snake.eat(this)
	}
}

class Direction {
	static directions {
		if (!__directions) {
				__directions = [
						Position.new(0, -1), // up
						Position.new(0, 1), // down
						Position.new(-1, 0), // left
						Position.new(1, 0) // right
				]
			}
			return __directions
		}
		
		static up {directions[0]}
		static down {directions[1]}
		static left {directions[2]}
		static right {directions[3]}
}

class Snake {
  tail {body[0]}
		neck {body[body.count - 2]}
		head {body[body.count - 1]}
		body {
			if (!_body) {
					var tail = Position.new(15, 8)
					var neck = Position.new(14, 8)
					var head = Position.new(13, 8)
					_body = [tail, neck, head]				 
				}
				return _body
		}
		
		direction {
			if (!_direction) {
				_direction = Direction.up
			}
			return _direction
		}
		
		state {_state}
		
		construct new(state) {
			_state = state
		}
		
		reset() {
			_body = null
			_direction = Direction.up
		}
		
		input() {
			var last = direction
			
			if (Input.up) {
				_direction = Direction.up
			}
			
			if (Input.down) {
				_direction = Direction.down
			}
			
			if (Input.left) {
				_direction = Direction.left
			}
			
			if (Input.right) {
				_direction = Direction.right
			}
			
			if (head.x + direction.x == neck.x &amp;&amp;
				head.y + direction.y == neck.y) {
					_direction = last
			}
		}
		
		draw() {
			body.each{|part|
			 T.rect(part.x * 8, part.y * 8, 8, 8, Color.blue)
			}
		}
		
		update() {
		
			var x = (head.x + direction.x) % 30
			if (x &lt; 0) {
				x = 29
			}
			
			var y = (head.y + direction.y) % 17
			if (y &lt; 0) {
				y = 17
			}
			
			var part = Position.new(x, y)
			
			body.add(part)
		}
		
		removeTail() {
			body.removeAt(0)
		}
		
		eat(food) {
			if (head.x == food.x &amp;&amp; head.y == food.y) {
				T.sfx(0, "C-5", 10)
				state.scoreUp()
				food.place()
			} else {
				removeTail()
			}
		}
		
		collisions() {
				
				// Search if head collisions with body parts
				// omit last part since its the head
			body[0...(body.count - 1)].each{|part|
					if (head.x == part.x &amp;&amp; head.y == part.y) {
							state.gameover()
					}
			}
		}
}

class Stage {
  items {_items}
		
	construct new() {
		_items = []
	}
		
  add(object) {
			items.add(object)
	}
		
  input() {
			items.each{|object|
					object.input()
			}
	}
		
	draw() {
		items.each{|object|
			object.draw()
		}
	}
	
	update() {
		items.each{|object|
			object.update()
		}
	}
	
	collisions() {
		items.each{|object|
			object.collisions()
		}
	}
}

class GUI {
		state {_state}
		
		construct new(state) {
			_state = state
		}
		
		score() {
			T.print("SCORE %(state.score)", 5, 5, Color.blue)
			T.print("SCORE %(state.score)", 5, 4, Color.white)
		}
		
		gameover() {
			T.cls(Color.black)
			T.print("Game Over", (Screen.width/2) - 6 * 4.5, (Screen.height / 2), Color.white)
		}
		
		input() {
			if (!state.isPlaying &amp;&amp; Input.x) {
					state.start()
			}
		}
		
		update() {}
		collisions() {}
		
		draw() {
			if (state.isPlaying) {
					return score()
			}
			gameover()
		}
}

class Game is TIC {
		stage {
			if (!_stage) {
					GameState.game = this
					_stage = Stage.new()
					_stage.add(snake)
					_stage.add(food)
					_stage.add(gui)
			}
			return _stage
		}
		
		gui {
			if (!_gui) {
				_gui = GUI.new(GameState)
			}
			return _gui
		}
		
		snake {
			if (!_snake) {
				_snake = Snake.new(GameState)
				GameState.snake = _snake
			}
			return _snake
		}
		
		food {
			if (!_food) {
				_food = Food.new(snake)
			}
			return _food
		}
		
		construct new() {
				reset()
		}
		
		reset() {
			snake.reset()
		}
		
		TIC() {
			T.cls(Color.green)
			GameState.frameUp()
			input()
			
			if (GameState.isTenthFrame) { 
				update()
				collisions()
			}

			draw()
		}
		
		input() {
			stage.input()
		}
		
		update() {
			stage.update()
		}
		
		collisions() {
			stage.collisions()
		}
		
		draw() {
			stage.draw()
		}
}</programlisting>
</section>
</section>
</section>
</chapter>
<chapter xml:id="_soluciones_a_ejercicios">
<title>Soluciones a Ejercicios</title>
<simpara>Las siguientes son las soluciones a los ejercicios planteados en el libro. No necesariamente son la única forma de resolverlos. Se recomienda intentar resolver los ejercicios antes de ver las soluciones.</simpara>
<section xml:id="_capítulo_1">
<title>Capítulo 1</title>
<section xml:id="chap1-ex1-sol">
<title>Solución: <xref linkend="chap1-ex1"/></title>
<formalpara>
<title>Ejecución</title>
<para><literal>$ ./wren hola.wren</literal></para>
</formalpara>
<formalpara>
<title>Salida</title>
<para>
<screen linenumbering="numbered">¡Hola Wren!</screen>
</para>
</formalpara>
<formalpara>
<title>Código</title>
<para>
<programlisting language="js" linenumbering="numbered">// muestra: ¡Hola Wren!
System.print("¡Hola Wren!")</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_capítulo_3">
<title>Capítulo 3</title>
<section xml:id="chap3-ex1-sol">
<title>Solución: <xref linkend="chap3-ex1"/></title>
<formalpara>
<title>Ejecución</title>
<para><literal>$ ./wren donas.wren</literal></para>
</formalpara>
<formalpara>
<title>Código</title>
<para>
<programlisting language="js" linenumbering="numbered">var donas = Fn.new {|cantidad|
  // Tu código aquí
  var mensaje = "Número de donas:"
  if (cantidad &gt;= 10) {
    return "%(mensaje) muchas"
  }
  return "%(mensaje) %(cantidad)"
}


// Pruebas para evaluar que el ejercicio
// se ha completado exitosamente.
// no modificar.

var probar = Fn.new {|tengo, quiero|
  var prefijo = " X "
  if (tengo == quiero) {
    prefijo = " OK "
  }
  System.print("%(prefijo) tengo: %(tengo) quiero: %(quiero)")
}

System.print("Probando donas")
probar.call(donas.call(4), "Número de donas: 4")
probar.call(donas.call(9), "Número de donas: 9")
probar.call(donas.call(10), "Número de donas: muchas")
probar.call(donas.call(99), "Número de donas: muchas")
System.print()</programlisting>
</para>
</formalpara>
</section>
</section>
</chapter>
<glossary xml:id="_glosario">
<title>Glosario</title>
<simpara>Lista de conceptos utilizados a lo largo de este documento.</simpara>
<glossentry>
<glossterm>class</glossterm>
<glossdef>
<simpara>Significa <emphasis>"clase"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>call</glossterm>
<glossdef>
<simpara>Significa <emphasis>"llamar"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>construct</glossterm>
<glossdef>
<simpara>Significa <emphasis>"constructor"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>object</glossterm>
<glossdef>
<simpara>Significa <emphasis>"objeto"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>start</glossterm>
<glossdef>
<simpara>Inicio, principio, comienzo.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>end</glossterm>
<glossdef>
<simpara>Fin, término, final.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>each</glossterm>
<glossdef>
<simpara>Palabra que significa <emphasis>"cada uno"</emphasis>. Usado en ciclos iterativos para evaluar cada uno de los elementos.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>for</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"para"</emphasis>. Usada dentro de los bucles y en conjunto a la instruacción <emphasis>"import"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>foreign</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"extranjero"</emphasis>. Usada para indicar que la clase, propiedad o variable será implementada fuera de <emphasis>Wren</emphasis>. Normalmente cuando se necesita utilizar código en otros lenguajes como <emphasis>C</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>false</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"falso"</emphasis>. Usado para indicar una condición no se está cumpliendo. Su contraparte es la instrucción <emphasis>"true"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>fiber</glossterm>
<glossdef>
<simpara>Significa <emphasis>"fibra"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>fn</glossterm>
<glossdef>
<simpara>Significa <emphasis>"función"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>función</glossterm>
<glossdef>
<simpara>Bloque de código que puede ser ejecutado en distintos puntos del ciclo de vida del código. También puede ser asignado a variables.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>new</glossterm>
<glossdef>
<simpara>Significa <emphasis>"nuevo"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>print</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"mostrar"</emphasis> o <emphasis>"imprimir"</emphasis>. Usado para mostrar un valor.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>parámetro</glossterm>
<glossdef>
<simpara>Son variables que son enviados a las funciones. Pueden ser por valor o por referencia.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>static</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"estático"</emphasis>. Usado para indicar que una propiedad o método de una clase no necesita una instancia para ser invocado.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>string</glossterm>
<glossdef>
<simpara>Significa <emphasis>"cadena de caracteres"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>int</glossterm>
<glossdef>
<simpara>Significa <emphasis>"número entero"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>float</glossterm>
<glossdef>
<simpara>Significa <emphasis>"número decimal con punto flotante"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>random</glossterm>
<glossdef>
<simpara>Signfica <emphasis>"aleatorio"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>num</glossterm>
<glossdef>
<simpara>Significa <emphasis>"número"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>true</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"verdadero"</emphasis>. Usado para indica una condición que si se cumple. Su contraparte es la instrucción <emphasis>"false"</emphasis>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>trim</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"cortar"</emphasis>. Usado para eliminar caracteres dentro de un string.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>import</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"incluir"</emphasis>. Obtener datos desde un archivo e incluir sus contenidos en el contexto.
Ejemplo <literal>import "random" for Random</literal>.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>if</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"si"</emphasis>. Permite crear una condicional y controlar el flujo de datos dentro de un programa.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>is</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"es"</emphasis>. Permite evaluar si un objeto es miembro de un tipo de clase.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>else</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"en otro caso"</emphasis>. Normalmente usado para indicar una condición alternativa si la condición <emphasis>"if"</emphasis> principal no se cumple.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>var</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"variable"</emphasis>. Usado para declarar una nueva variable.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>while</glossterm>
<glossdef>
<simpara>Instrucción que significa <emphasis>"mientras"</emphasis>. Usada dentro de los bucles.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>write</glossterm>
<glossdef>
<simpara>Instrucción que signiica <emphasis>"escribir"</emphasis>.</simpara>
</glossdef>
</glossentry>
</glossary>
<bibliography xml:id="_bibliografía">
<title>Bibliografía</title>
<simpara>Una lista de recursos complementarios y referenciales.</simpara>
<bibliodiv>
<title>Libros</title>
<bibliomixed>
<bibliomisc><anchor xml:id="inventwithpython" xreflabel="[inventwithpython]"/>[inventwithpython] Albert Sweigart. 'Inventa tus Propios Juegos de computadora con Python'. <link xl:href="http://inventwithpython.com/es">http://inventwithpython.com/es</link>. ISBN 978-1514370926</bibliomisc>
</bibliomixed>
<bibliomixed>
<bibliomisc><anchor xml:id="alfonseca" xreflabel="[alfonseca]"/>[alfonseca] Manuel Alfonseca. 'Cómo construir juegos de aventura'. <link xl:href="https://worldofspectrum.org/archive/books/enciclopedia-practica-de-la-informatica-aplicada-1-como-construir-juegos-de-aventura">https://worldofspectrum.org/archive/books/enciclopedia-practica-de-la-informatica-aplicada-1-como-construir-juegos-de-aventura</link>. ISBN 84-7688-019-7</bibliomisc>
</bibliomixed>
<bibliomixed>
<bibliomisc><anchor xml:id="thinkpython" xreflabel="[thinkpython]"/>[thinkpython] Allen Downey. 'Think Python: How to Think Like a Computer Scientist, Traducción de Jorge Espinoza'. <link xl:href="https://github.com/espinoza/ThinkPython2-spanish">https://github.com/espinoza/ThinkPython2-spanish</link>. ISBN 978-1491939369</bibliomisc>
</bibliomixed>
</bibliodiv>
<bibliodiv>
<title>Sitios Web</title>
<bibliomixed>
<bibliomisc><anchor xml:id="introtopython" xreflabel="[introtopython]"/>[introtopython] Eric Matthes. 'Introduction to Python' <link xl:href="https://github.com/ehmatthes/intro_programming">https://github.com/ehmatthes/intro_programming</link></bibliomisc>
</bibliomixed>
<bibliomixed>
<bibliomisc><anchor xml:id="googlepython" xreflabel="[googlepython]"/>[googlepython] Google. 'Python Class' <link xl:href="http://code.google.com/edu/languages/google-python-class/">http://code.google.com/edu/languages/google-python-class/</link></bibliomisc>
</bibliomixed>
<bibliomixed>
<bibliomisc><anchor xml:id="puntoflotante" xreflabel="[puntoflotante]"/>[puntoflotante] Michael Borgwardt. <link xl:href="https://github.com/Pybonacci/puntoflotante.org">https://github.com/Pybonacci/puntoflotante.org</link></bibliomisc>
</bibliomixed>
<bibliomixed>
<bibliomisc><anchor xml:id="rosettacode-wren" xreflabel="[rosettacode-wren]"/>[rosettacode-wren] Rosetta Code. <link xl:href="https://rosettacode.org/wiki/Category:Wren">https://rosettacode.org/wiki/Category:Wren</link></bibliomisc>
</bibliomixed>
<bibliomixed>
<bibliomisc><anchor xml:id="mit600" xreflabel="[mit600]"/>[mit600] Introduction to Computer Science and Programming. <link xl:href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/</link></bibliomisc>
</bibliomixed>
<bibliomixed>
<bibliomisc><anchor xml:id="exercism" xreflabel="[exercism]"/>[exercism] Exercism. 'Wren Track' <link xl:href="https://exercism.org/tracks/wren/">https://exercism.org/tracks/wren/</link></bibliomisc>
</bibliomixed>
</bibliodiv>
</bibliography>
<index xml:id="_índice">
<title>Índice</title>

</index>
</book>